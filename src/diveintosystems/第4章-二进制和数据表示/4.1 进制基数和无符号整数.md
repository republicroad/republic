Having seen that [binary sequences can be interpreted in all sorts of nonnumerical ways](https://diveintosystems.org/book/C4-Binary/index.html#_binary_and_data_representation), let’s turn our attention to numbers. Specifically, we’ll start with **unsigned** numbers, which can be interpreted as zero or positive, but they can never be negative (they have no _sign_).
看到[二进制序列可以用各种非数字方式解释](4.0%20二进制和数据表示.md)，让我们将注意力转向数字。具体来说，我们将从**无符号**数字开始，这些数字可以解释为零或正数，但它们永远不能为负数（它们没有 _符号_）。

### 4.1.1. 小数

Rather than starting with binary, let’s first examine a number system we’re already comfortable using, the **decimal number system**, which uses a _base_ of 10. _Base 10_ implies two important properties for the interpretation and representation of decimal values.

1. Any individual digit in a base 10 number stores one of 10 unique values (0-9). To store a value larger than 9, the value must **carry** to an additional digit to the left. For example, if one digit starts at its maximum value (9) and we add 1 to it, the result requires two digits (9 + 1 = 10). The same pattern holds for any digit, regardless of its position within a number (e.g., 50**8**0 + **2**0 = 5**10**0).
    
2. The position of each digit in the number determines how important that digit is to the overall value of the number. Labeling the digits from _right to left_ as d0, d1, d2, etc., each successive digit contributes a factor of _ten_ more than the next. For example, take the value 8425 ([Figure 1](https://diveintosystems.org/book/C4-Binary/bases.html#FigBaseTen)).

我们先不从二进制开始，而是先检查一下我们已经习惯使用的数字系统，即**十进制数字系统**，它使用 _base_ 为 10。_Base 10_ 意味着解释和表示十进制值的两个重要属性。

1. 以 10 为基数的数字中的任何单个数字都存储 10 个唯一值 (0-9) 之一。要存储大于 9 的值，该值必须**进位** 到左侧的附加数字。例如，如果一位数字从最大值 (9) 开始，我们加 1，则结果需要两位数字 (9 + 1 = 10)。相同的模式适用于任何数字，无论其在数字中的位置如何（例如，50**8**0 + **2**0 = 5**10**0）。
2. 数字中每个数字的位置决定了该数字对于数字总价值的重要性。将从右到左的数字标记为 d0、d1、d2 等，每个连续的数字比下一个数字贡献 _十_ 倍。例如，取值 8425（[图 1](https://diveintosystems.org/book/C4-Binary/bases.html#FigBaseTen)）。

![For the number 8425, digit 0 is the 5, which is in the "ones place".  Digit 1 is the 2, which is in the "tens place".  Digit 2 is the 4, in the "hundreds place".  Finally, digit 3 is the 8, in the "thousands place".](https://diveintosystems.org/book/C4-Binary/_images/BaseTen.png)

Figure 1. The importance of each digit in a base 10 number, using names that you may have given to each digit in grade school.
图 1. 以 10 为基数的数字中每个数字的重要性，使用您在小学时可能给每个数字起的名称。

For the example value 8425, the 5 in the "ones" place contributes 5 (5 × 100). The 2 in the "tens" place contributes 20 (2 × 101). The 4 in the "hundreds" place contributes 400 (4 × 102), and, finally, the 8 in the "thousands" place contributes 8000 (8 × 103). More formally, one could express 8425 as
对于示例值 8425，“个位”中的 5 贡献 5 (5 × 10<sup>0</sup>)。 “十位”的 2 贡献 20 (2 × 10<sup>1</sup>)。 “百位”中的 4 贡献了 400 (4 × 10<sup>2</sup>)，最后，“千位”中的 8 贡献了 8000 (8 × 10<sup>3</sup>)。更正式地说，可以将 8425 表示为

(8 × 10<sup>3</sup>)    +    (4 × 10<sup>2</sup>)    +    (2 × 10<sup>1</sup>)    +    (5 × 10<sup>0</sup>)

This pattern of increasing exponents applied to a base of 10 is the reason why it’s called a _base 10_ number system. Assigning position numbers to digits from right to left starting with d0 implies that each digit di contributes 10i to the overall value. Thus, the overall value of any _N_-digit decimal number can be expressed as:
这种以 10 为底的指数递增模式就是它被称为 _base 10_ 数字系统的原因。将位置编号分配给从右到左从 d0 开始的数字意味着每个数字 di 为总价值贡献 10i 。因此，任何 _N_ 位十进制数的总值可以表示为：

(d<sub>N-1</sub> × 10<sup>N-1</sup>)    +    (d<sub>N-2</sub> × 10<sup>N-2</sup>)    +    …​    +    (d<sub>2</sub> × 10<sup>2</sup>)    +    (d<sub>1</sub> × 10<sup>1</sup>)    +    (d<sub>0</sub> × 10<sup>0</sup>)

Fortunately, as we’ll soon see, a very similar pattern applies to other number systems.
> [!NOTE] Distinguishing Number Bases
> Now that we’re about to introduce a second number system, one potential problem is a lack of clarity regarding how to interpret a number. For example, consider the value 1000. It’s not immediately obvious whether you should interpret that number as a decimal value (i.e., one thousand) or a binary value (i.e., eight, for reasons explained soon). To help clarify, the remainder of this chapter will explicitly attach a prefix to all nondecimal numbers. We’ll soon introduce binary, for which the prefix is **0b**, and hexadecimal, which uses a prefix of **0x**.
> 
>Therefore, if you see 1000, you should assume it’s a decimal "one thousand", and if you see 0b1000, you should interpret it as a binary number, in this case the value "eight".

幸运的是，正如我们很快就会看到的，非常相似的模式也适用于其他数字系统。
> [!NOTE] 区分不同进制数基
> 在我们即将引入第二个数字系统，一个潜在的问题是如何解释数字缺乏清晰度。例如，考虑值 1000。是否应该将该数字解释为十进制值（即 1000）还是二进制值（即 8，原因很快就会解释），这一点并不是很明显。为了帮助澄清，本章的其余部分将明确为所有非十进制数字附加一个前缀。我们很快将介绍二进制（前缀为 **0b**）和十六进制（使用前缀 **0x**）。
> 
>因此，如果您看到 1000，您应该假设它是十进制“一千”，如果您看到 0b1000，您应该将其解释为二进制数，在本例中为值“八”。

### 4.1.2. 无符号二进制数

While you may never have considered the specific formula describing decimal numbers as powers of 10, the concept of { _ones_, _tens_, _hundreds_, etc. } places should hopefully feel comfortable. Luckily, similar terminology applies to other number systems, like binary. Of course, the base is different in other number systems, so each digit position contributes a different amount to its numerical value.

虽然您可能从未考虑过将十进制数描述为 10 的幂的具体公式，但 { _个位_, _十位_, _百位_, 等. } 位的概念应该会让您感到熟悉。幸运的是，类似的术语适用于其他数字系统，例如二进制。当然，其他数字系统中的基数不同，因此每个数字位置对其数值的贡献量不同。

A **binary number system** uses a base of 2 instead of decimal’s 10. Analyzing it the same way that we just did for decimal reveals several parallels (with 2 substituted for 10):

1. Any individual bit in a base 2 number stores one of two unique values (0 or 1). To store a value larger than 1, the binary encoding must **carry** to an additional bit to the left. For example, if one bit starts at its maximum value (1) and we add 1 to it, the result requires two bits (1 + 1 = 0b10). The same pattern holds for any bit, regardless of its position within a number (e.g., 0b100**1**00 + 0b**1**00 = 0b10**10**00).
    

2. The position of each bit in the number determines how important that bit is to the numerical value of the number. Labeling the digits from _right to left_ as d0, d1, d2, etc., each successive bit contributes a factor of _two_ more than the next.

**二进制数字系统**使用基数 2，而不是十进制的 10。以与我们刚才对十进制相同的方式进行分析，可以发现几个相似之处（用 2 代替 10）：
1. 以 2 为基数的数字中的任何单个位都存储两个唯一值（0 或 1）之一。要存储大于 1 的值，二进制编码必须**进位** 到左侧的附加位。例如，如果一位从最大值 (1) 开始，并且我们向其加 1，则结果需要两位 (1 + 1 = 0b10)。相同的模式适用于任何位，无论其在数字中的位置如何（例如，0b100**1**00 + 0b**1**00 = 0b10**10**00）。
2. 数字中每一位的位置决定了该位对于数字的数值的重要性。将从右到左的数字标记为 d0、d1、d2 等，每个连续位的贡献比下一位多 _两倍_ 。

The first point implies that counting in binary follows the same pattern as decimal: by simply enumerating the values and adding digits (bits). Because this section focuses on _unsigned_ numbers (zero and positives only), it’s natural to start counting from zero. [Table 1](https://diveintosystems.org/book/C4-Binary/bases.html#TabBinaryCounting) shows how to count the first few natural numbers in binary. As you can see from the table, counting in binary quickly increases the number of digits. Intuitively, this growth makes sense, since each binary digit (two possible values) represents less information than a decimal digit (10 possible values).

第一点意味着二进制计数遵循与十进制相同的模式：通过简单地枚举值并添加数字（位）。由于本节重点介绍_无符号_数字（仅零和正数），因此很自然地从零开始计数。 [表 1](https://diveintosystems.org/book/C4-Binary/bases.html#TabBinaryCounting) 显示了如何计算二进制中的前几个自然数。从表中可以看出，以二进制计数很快就会增加位数。直观上，这种增长是有道理的，因为每个二进制数字（两个可能的值）代表的信息少于十进制数字（10 个可能的值）。

Table 1. A Comparison of Counting in Binary versus Decimal
表 1. 二进制与十进制计数的比较

|Binary value|Decimal value|
|---|---|
|0|0|
|1|1|
|10|2|
|11|3|
|100|4|
|101|5|
|…​|…​|

The second point about labeling digits looks really familiar! In fact, it’s so similar to decimal that it leads to a nearly identical formula for interpreting a binary number. Simply replace the 10 at the base of each exponent with a 2:

关于标记数字的第二点看起来非常熟悉！事实上，它与十进制非常相似，以至于可以得出几乎相同的解释二进制数的公式。只需将每个指数底部的 10 替换为 2：

(d<sub>N-1</sub> × 2<sup>N-1</sup>)    +    (d<sub>N-2</sub> × 2<sup>N-2</sup>)    +    …​    +    (d<sub>2</sub> × 2<sup>2</sup>)    +    (d<sub>1</sub> × 2<sup>1</sup>)    +    (d<sub>0</sub> × 2<sup>0</sup>)

Applying this formula yields the _unsigned_ interpretation of any binary number. For example, take 0b1000:

(1 × 2<sup>3</sup>)    +    (0 × 2<sup>2</sup>)    +    (0 × 2<sup>1</sup>)    +    (0 × 2<sup>0</sup>)

  =    8 + 0 + 0 + 0    =    8

Here’s a longer one-byte example, 0b10110100:

(1 × 2<sup>7</sup>)    +    (0 × 2<sup>6</sup>)    +    (1 × 2<sup>5</sup>)    +    (1 × 2<sup>4</sup>)    +    (0 × 2<sup>3</sup>)    +    (1 × 2<sup>2</sup>)    +    (0 × 2<sup>1</sup>)    +    (0 × 2<sup>0</sup>)

  =    128 + 0 + 32 + 16 + 0 + 4 + 0 + 0    =    180

### 4.1.3. 十六进制

Thus far, we’ve examined two number systems, decimal and binary. Decimal is notable due to its comfort for humans, whereas binary matches the way data is stored in hardware. It’s important to note that they are equivalent in their expressive power. That is, there’s no number you can represent in one system that you can’t represent in the other. Given their equivalence, it may surprise you that we’re going to discuss one more number system: the base 16 **hexadecimal** system.
到目前为止，我们已经研究了两种数字系统：十进制和二进制。十进制因其对人类的舒适性而引人注目，而二进制则与数据在硬件中存储的方式相匹配。值得注意的是，它们的表达能力是相当的。也就是说，没有任何数字可以在一个系统中表示而不能在另一个系统中表示。考虑到它们的等价性，您可能会感到惊讶，我们将讨论另一种数字系统：以 16 为基数的**十六进制**系统。

With two perfectly good number systems, you may wonder why we need another. The answer is primarily convenience. As shown in [Table 1](https://diveintosystems.org/book/C4-Binary/bases.html#TabBinaryCounting), binary bit sequences quickly grow to a large number of digits. Humans tend to have a tough time making sense of long sequences containing only 0’s and 1’s. And whereas decimal is more compact, its base of 10 is a mismatch with binary’s base 2.
有了两个完美的数字系统，您可能想知道为什么我们需要另一个。答案主要是方便。如[表 1](https://diveintosystems.org/book/C4-Binary/bases.html#TabBinaryCounting) 所示，二进制位序列快速增长到大量数字。人类往往很难理解仅包含 0 和 1 的长序列。尽管十进制更紧凑，但它的基数 10 与二进制的基数 2 不匹配。

Decimal doesn’t easily capture the range that can be expressed using a fixed number of bits. For example, suppose that an old computer uses 16-bit memory addresses. Its valid addresses range from 0b0000000000000000 to 0b1111111111111111. Represented in decimal, the addresses range from 0 to 65535. Clearly, the decimal representations are more compact than the long binary sequences, but unless you memorize their conversions, it’s more difficult to reason about the decimal numbers. Both problems only get worse on modern devices, which use 32- or 64-bit addresses!
十进制不容易捕获可以使用固定位数表示的范围。例如，假设一台旧计算机使用 16 位内存地址。其有效地址范围为 0b0000000000000000 到 0b1111111111111111。以十进制表示，地址范围从 0 到 65535。显然，十进制表示比长二进制序列更紧凑，但除非您记住它们的转换，否则很难推理十进制数字。在使用 32 位或 64 位地址的现代设备上，这两个问题只会变得更糟！

These long bit sequences are where hexadecimal’s base 16 shines. The large base allows each digit to represent enough information for hexadecimal numbers to be compact. Furthermore, because the base is itself a power of two (24 = 16), it’s easy to map hexadecimal to binary, and vice versa. For the sake of completeness, let’s analyze hexadecimal in the same way as decimal and binary:

1. Any individual digit in a base 16 number stores one of 16 unique values. Having more than 10 values presents a new challenge for hexadecimal — traditional base 10 digits stop at a maximum value of 9. By convention, hexadecimal uses letters to represent values larger than 9, with A for 10, B for 11, up to F for 15. Like the other systems, to store a value larger than 15, the number must **carry** to an additional digit to the left. For example, if one digit starts at its maximum value (F) and we add 1 to it, the result requires two digits (0xF + 0x1 = 0x10; note that we use 0x to indicate hexadecimal numbers).
    
2. The position of each digit in the number determines how important that digit is to the numerical value of the number. Labeling the digits from _right to left_ as d0, d1, d2, etc., each successive digit contributes a factor of 16 more than the next.

这些长位序列正是十六进制的 16 进制的亮点。大基数允许每个数字表示足够的信息，使十六进制数变得紧凑。此外，由于基数本身就是 2 的幂 (24 = 16)，因此很容易将十六进制映射到二进制，反之亦然。为了完整起见，我们用十进制和二进制同样的方式来分析十六进制：
1. 16 进制数字中的任何单个数字都存储 16 个唯一值之一。超过 10 个值对十六进制提出了新的挑战——传统的 10 位数字的最大值为 9。按照惯例，十六进制使用字母来表示大于 9 的值，其中 A 代表 10，B 代表 11，最多 F 代表 15。与其他系统一样，要存储大于 15 的值，数字必须**进位**到左侧的附加数字。例如，如果一位数字从最大值 (F) 开始，并且我们向其加 1，则结果需要两位数字（0xF + 0x1 = 0x10；请注意，我们使用 0x 表示十六进制数字）。
2. 数字中每个数字的位置决定了该数字对于数字的数值的重要性。将从右到左的数字标记为 d0、d1、d2 等，每个连续数字的贡献比下一个数字多 16 倍。

Unsurprisingly, the same trusty formula for interpreting a number applies to hexadecimal, with 16 as the base:
毫不奇怪，解释数字的相同可靠公式也适用于以 16 为基数的十六进制：

(d<sub>N-1</sub> × 16<sup>N-1</sup>)    +    (d<sub>N-2</sub> × 16<sup>N-2</sup>)    +    …​    +    (d<sub>2</sub> × 16<sup>2</sup>)    +    (d<sub>1</sub> × 16<sup>1</sup>)    +    (d<sub>0</sub> × 16<sup>0</sup>)

For example, to determine the decimal value of 0x23C8:
例如，要确定 0x23C8 的十进制值：

   (2 × 16<sup>3</sup>)    +    (3 × 16<sup>2</sup>)    +    (C × 16<sup>1</sup>)    +    (8 × 16<sup>0</sup>)

  =    (2 × 16<sup>3</sup>)    +    (3 × 16<sup>2</sup>)    +    (12 × 16<sup>1</sup>)    +    (8 × 16<sup>0</sup>)

  =    (2 × 4096)    +    (3 × 256)    +    (12 × 16)    +    (8 × 1)

  =    8192 + 768 + 192 + 8    =    9160


> [!NOTE] Hexadecimal Misconception
> You may not encounter hexadecimal numbers frequently as you’re first learning about systems programming. In fact, the only context where you’re likely to find them is in representing memory addresses. For example, if you print the address of a variable using the `%p` (pointer) format code for `printf`, you’ll get hexadecimal output.
> 
> Many students often begin to equate memory addresses (e.g., C pointer variables) with hexadecimal. While you may get used to seeing addresses represented that way, keep in mind that _they are still stored using binary in the hardware_, just like all other data!


> [!NOTE] 十六进制误解
> 当您第一次学习系统编程时，您可能不会经常遇到十六进制数字。事实上，您可能找到它们的唯一上下文是表示内存地址。例如，如果您使用`printf`的`%p`（指针）格式代码打印变量的地址，您将获得十六进制输出。
> 
> 许多学生经常开始将内存地址（例如，C 指针变量）与十六进制等同起来。虽然您可能习惯以这种方式表示地址，但请记住 _它们仍然在硬件中使用二进制存储_ ，就像所有其他数据一样！

### 4.1.4. 存储限制

Conceptually, there are infinitely many unsigned integers. In practice, a programmer must choose how many bits to dedicate to a variable _prior to storing it_, for a variety of reasons:

- Before storing a value, a program must allocate storage space for it. In C, declaring a variable tells the compiler [how much memory](https://diveintosystems.org/book/C1-C_intro/getting_started.html#_c_numeric_types) it needs based on its type.
- Hardware storage devices have finite capacity. Whereas a system’s main memory is typically large and unlikely to be a limiting factor, storage locations inside the CPU that are used as temporary "scratch space" (i.e., [registers](https://diveintosystems.org/book/C5-Arch/storagecircs.html#_cpu_register)) are more constrained. A CPU uses registers that are limited to its word size (typically 32 or 64 bits, depending on the CPU architecture).
- Programs often move data from one storage device to another (e.g., between CPU registers and main memory). As values get larger, storage devices need more wires to communicate signals between them. Hence, expanding storage increases the complexity of the hardware and leaves less physical space for other components.

从概念上讲，无符号整数有无限多个。在实践中，出于多种原因，程序员必须在存储变量之前选择专用于变量的位数：
- 在存储一个值之前，程序必须为其分配存储空间。在 C 中，声明变量会根据其类型告知编译器需要多少内存。
- 硬件存储设备的容量是有限的。虽然系统的主内存通常很大并且不太可能成为限制因素，但 CPU 内用作临时“暂存空间”的存储位置（即[寄存器](https://diveintosystems.org/book/C5-Arch/storagecircs.html#_cpu_register)）受到更多限制。 CPU 使用的寄存器受到字大小的限制（通常为 32 或 64 位，具体取决于 CPU 架构）。
- 程序经常将数据从一个存储设备移动到另一存储设备（例如，在 CPU 寄存器和主存储器之间）。随着值变大，存储设备需要更多的电线来在它们之间传递信号。因此，扩展存储会增加硬件的复杂性，并为其他组件留下更少的物理空间。


The number of bits used to store an integer dictates the range of its representable values. [Figure 2](https://diveintosystems.org/book/C4-Binary/bases.html#FigUnsignedLine) depicts how we might conceptualize infinite and finite unsigned integer storage spaces.
用于存储整数的位数决定了其可表示值的范围。 [图 2](https://diveintosystems.org/book/C4-Binary/bases.html#FigUnsignedLine) 描绘了我们如何概念化无限和有限无符号整数存储空间。

![The infinite unsigned number line starts at zero and increases infinitely.  The finite unsigned number line starts at 0 and ends at a maximum value.  Attempting to move off one end wraps around to the other.](https://diveintosystems.org/book/C4-Binary/_images/UnsignedLine.png)

Figure 2. Illustrations of (a) an infinite unsigned number line and (b) a finite unsigned number line. The latter "wraps around" at either endpoint (overflow).
图 2. (a) 无限无符号数轴和 (b) 有限无符号数轴的图示。后者在任一端点“环绕”（溢出）。

Attempting to store a larger value to a variable than the variable’s size allows is known as **integer overflow**. This chapter defers the details of overflow to a [later section](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow). For now, think of it like a car’s odometer that "rolls over" back to zero if it attempts to increase beyond its maximum value. Similarly, subtracting one from zero yields the maximum value.
尝试向变量存储比变量大小允许的更大的值称为**整数溢出**。本章将溢出的详细信息推迟到[后面的部分](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow)。现在，可以把它想象成汽车的里程表，如果它试图增加超过其最大值，它就会“翻转”回零。同样，从零减一得到最大值。

At this point, a natural question to ask about unsigned binary is "_What’s the largest positive value that N bits can store?_" In other words, given a sequence of _N_ bits that are all 1, what value does the sequence represent? Reasoning about this question informally, the analysis in the [previous section](https://diveintosystems.org/book/C4-Binary/index.html#_binary_and_data_representation) shows that _N_ bits yield  2<sup>N</sup> unique bit sequences. Since one of those sequences must represent the number 0, that leaves  2<sup>N</sup> - 1 positive values ranging from 1 to  2<sup>N</sup> - 1. Thus, the maximum value for an unsigned binary number of _N_ bits must be  2<sup>N</sup> - 1.
此时，关于无符号二进制，一个自然要问的问题是“N 位可以存储的最大正值是多少？”换句话说，给定一个全 1 的 N 位序列，该序列代表什么值？非正式地推理这个问题，[上一节](https://diveintosystems.org/book/C4-Binary/index.html#_binary_and_data_representation)中的分析表明，_N_ 位产生 2<sup>N</sup> 个唯一的位序列。由于这些序列之一必须表示数字 0，因此会留下  2<sup>N</sup> - 1 个介于 1 到  2<sup>N</sup> - 1 之间的正值。因此，_N_ 位无符号二进制数的最大值必须是  2<sup>N</sup> - 1。

For example, 8 bits provide 28 = 256 unique sequences. One of those sequences, 0b00000000, is reserved for 0, leaving 255 sequences for storing positive values. Therefore, an 8-bit variable represents the positive values 1 through 255, the largest of which is 255.
例如，8 位提供 28 = 256 个唯一序列。这些序列之一 0b00000000 被保留为 0，剩下 255 个序列用于存储正值。因此，8 位变量表示 1 到 255 之间的正值，其中最大的是 255。