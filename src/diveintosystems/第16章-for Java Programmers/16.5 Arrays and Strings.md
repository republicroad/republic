## 16.5. 数组和字符串

An **array** is a C construct that creates an ordered collection of data elements of the same type and associates this collection with a single program variable. **Ordered** means that each element is in a specific position in the collection of values (that is, there is an element in position 0, position 1, and so on), not that the values are necessarily sorted. Arrays are one of C’s primary mechanisms for grouping multiple data values and referring to them by a single name. Arrays come in several flavors, but the basic form is a _one-dimensional array_, which is useful for implementing list-like data structures and strings in C. C arrays are most similar to Java’s Array class.

**数组** 是一种 C 语言结构，它创建由相同类型数据元素组成的有序集合，并将该集合与单个程序变量关联。**有序** 意味着每个元素在值集合中都处于特定位置（即，在位置 0、位置 1 等处都有一个元素），而不一定表示值已排序。数组是 C 语言用于对多个数据值进行分组并通过单个名称引用它们的主要机制之一。数组有几种类型，但基本形式是_一维数组_，这对于在 C 语言中实现类似列表的数据结构和字符串很有用。C 数组与 Java 的 Array 类最为相似。

### [](https://diveintosystems.org/book/Appendix1/arrays_strings.html#_introduction_to_arrays)16.5.1. 数组介绍

C arrays can store multiple data values of the _same_ type. In this chapter, we discuss **statically declared** arrays, meaning that the total capacity (the maximum number of elements that can be stored in an array) is fixed and is defined when the array variable is declared. In the Chapter 2, we discuss [dynamically allocated arrays](https://diveintosystems.org/book/C2-C_depth/arrays.html#_dynamically_allocated) and [multi-dimensional arrays](https://diveintosystems.org/book/C2-C_depth/arrays.html#_two_dimensional_arrays).

C 数组可以存储多个相同类型的数据值。在本章中，我们讨论**静态声明**的数组，这意味着总容量（数组中可以存储的最大元素数）是固定的，并且在声明数组变量时定义。在第 2 章中，我们讨论[动态分配的数组](https://diveintosystems.org/book/C2-C_depth/arrays.html#_dynamically_allocated)和[多维数组](https://diveintosystems.org/book/C2-C_depth/arrays.html#_two_Dimensional_arrays)。

[Table 1](https://diveintosystems.org/book/Appendix1/arrays_strings.html#TabJavaArrayComparison) shows Java and C versions of a program that initializes and then prints a collection of integer values. Both the Java and the C versions use an array of `int` types to store the collection of values.
  
[表 1](https://diveintosystems.org/book/Appendix1/arrays_strings.html#TabJavaArrayComparison) 显示了 Java 和 C 版本的程序，该程序初始化然后打印一组整数值。Java 和 C 版本都使用 `int` 类型的数组来存储值集合。

In general, Java provides a high-level interfaces to the programmer that hide much of the low-level implementation details. C, on the other hand, exposes a low-level array implementation to the programmer and leaves it up to the programmer to implement higher-level functionality. In other words, arrays enable low-level data storage without higher-level list functionality, such as `length`, `compare`, `binarySearch`, and so on. Java also provides several higher-level list abstractions in its `List` and `ArrayList` classes, both of which support dynamically resizing of the list of values. In contrast, it is up to the C programmer to implement these types of abstractions on top of its fixed-size arrays.

一般来说，Java 为程序员提供了高级接口，隐藏了许多低级实现细节。另一方面，C 向程序员公开了低级数组实现，并将高级功能留给程序员实现。换句话说，数组支持低级数据存储，而没有高级列表功能，例如`长度`、`比较`、`二进制搜索`等。Java 还在其`List`和`ArrayList`类中​​提供了几个高级列表抽象，它们都支持动态调整值列表的大小。相比之下，C 程序员则需要在固定大小的数组之上实现这些类型的抽象。

Table 1. Syntax Comparison of Arrays in Java and C
表 1. Java 和 C 中数组的语法比较

| Java version                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | C version                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <pre><code>/* Example Java program using an Array */<br><br>class ArrayExample {<br><br> public static void  main(String[] args) {<br><br>   int i, size = 0;<br><br>   // create and init array of 3 ints<br>   int[] small_arr = {1, 3, 5};<br><br>   // declare and create array of 10 ints<br>   int[] nums = new int[10];<br><br>   // set value of each element<br>   for (i = 0; i < 10; i++) {<br>      nums[i] = i;<br>      size++;<br>   }<br><br>   // set value at position 3 to 5<br>   nums[3] = small_arr[2];<br><br>   // print number of array elements<br>   System.out.printf("array size: %d\n",<br>        size);  // or nums.length<br><br>   // print each element of nums<br>   for (i = 0; i < 10; i++) {<br>     System.out.printf("%d\n", nums[i]);<br>   }<br><br> }<br>}</code></pre> | <pre><code>/\* Example C program using arrays \*/<br><br>\#include <stdio.h><br><br>int main(void) {<br><br>  int i, size = 0;<br><br>  // declare and init array of 3 ints<br>  int small_arr[] = {1, 3, 5};<br><br>  // declare array of 10 ints<br>  int nums[10];<br><br>  // set value of each element<br>  for (i = 0; i < 10; i++) {<br>    nums[i] = i;<br>    size++;<br>  }<br><br>  // set value at position 3 to 5<br>  nums[3] = small_arr[2];<br><br>  // print number of array elements<br>  printf("array size: %d\n",<br>         size);<br><br>  // print each element of nums<br>  for (i = 0; i < 10; i++) {<br>    printf("%d\n", nums[i]);<br>  }<br><br>  return 0;<br>}</code></pre> |

The C and Java versions of this program are almost identical. In particular, the individual elements can be accessed via **indexing**, and that index values start at `0`. That is, both languages refer to the very first element in a collection as the element at position `0`.

该程序的 C 和 Java 版本几乎完全相同。具体来说，可以通过 **索引** 访问各个元素，并且索引值从 `0` 开始。也就是说，两种语言都将集合中的第一个元素称为位置 `0` 处的元素。

In both C and Java arrays are fixed-capacity data structures (vs. ones that grow in capacity as more elements are added). The main differences in the C and Java versions of this program relate to how the array type is declared and how space for its capacity is allocated.

在 C 和 Java 中，数组都是固定容量的数据结构（相对于随着添加更多元素而容量增加的数据结构）。此程序的 C 和 Java 版本的主要区别在于数组类型的声明方式以及如何分配其容量空间。

In Java, the syntax for an array type is `<typename>[]` and space for an array of a some capacity is allocated using `new <typename>[<capacity>]`. For example:

在 Java 中，数组类型的语法是 `<typename>[]`，并且使用 `new <typename>[<capacity>]` 为一定容量的数组分配空间。例如：

For a Java array:
对于 Java 数组：

```java
int[] nums;          // declare nums as an array of int
nums = new int[10];  // create a new int array of capacity 10
```

In C, array types are declared using `<typename> <varname>[<capacity>]`. For example:
在 C 语言中，数组类型使用 `<typename> <varname>[<capacity>]` 声明。例如：

For a C array:
对于 C 数组：

```c
int nums[10];    // declare nums as an array of capacity 10
```

When declaring an array variable in C, the programmer must specify its type (the type of each value stored in the array) and its total capacity (the maximum number of storage locations) as part of the definition. For example:
在 C 语言中声明数组变量时，程序员必须在定义中指定其类型（数组中存储的每个值的类型）及其总容量（最大存储位置数）。例如：

```c
int  arr[10];  // declare an array of 10 ints
char str[20];  // declare an array of 20 chars
```

The preceding declarations create one variable named `arr`, an array of `int` values with a total capacity of 10, and another variable named `str`, an array of `char` values with a total capacity of 20.
上述声明创建了一个名为`arr`的变量，一个总容量为 10 的`int`值数组，以及另一个名为`str`的变量，一个总容量为 20 的`char`值数组。

Both Java and C also allow a programmer to both declare and initialize the elements in the declaration (the `small_arr` array in both is an array with capacity 3 that stores the int values `1`, `3`, and `5`):
Java 和 C 都允许程序员声明和初始化声明中的元素（两者中的 `small_arr` 数组都是容量为 3 的数组，用于存储 int 值 `1`、`3` 和 `5`）：

```java
// java version:
int[]  small_arr = {1, 3, 5};
```

```c
// C version:
int  small_arr[] = {1, 3, 5};
```

Because arrays are objects in Java, there are a large set of methods of the Array class that can be used to interact with Java arrays beyond simple indexing to get and set values. Some of these include methods to search the array and to create other data structures from the array. C’s array support is limited to creating an ordered collection of elements of the same type, and supporting indexing to access individual array elements. Any higher-level processing on the array must be implemented by a C programmer.

由于数组是 Java 中的对象，因此 Array 类中有很多方法可用于与 Java 数组交互，而不仅仅是通过简单的索引来获取和设置值。其中一些方法包括搜索数组和从数组创建其他数据结构的方法。C 对数组的支持仅限于创建相同类型元素的有序集合，并支持索引以访问单个数组元素。对数组的任何高级处理都必须由 C 程序员实现。

Both Java and C store array values in contiguous memory locations. C dictates the array layout in program memory, whereas Java hides some of the details of this from the programmer. In C, individual array elements are allocated in consecutive locations in the program’s memory. For example, the third array position is located in memory immediately following the second array position and immediately before the fourth array position. The same is true for Java, however often what is stored in a Java array is an object reference and not the object value itself. As a result, although the object references of contiguous array elements are stored contiguously in program memory, the objects to which they refer may not be stored contiguously in memory.

Java 和 C 都将数组值存储在连续的内存位置中。C 规定了程序内存中的数组布局，而 Java 向程序员隐藏了其中的一些细节。在 C 中，各个数组元素分配在程序内存中的连续位置。例如，第三个数组位置位于内存中紧接着第二个数组位置之后，紧接着第四个数组位置之前。Java 也是如此，但是 Java 数组中存储的通常是对象引用，而不是对象值本身。因此，尽管连续数组元素的对象引用在程序内存中连续存储，但它们引用的对象可能不是在内存中连续存储的。
### [](https://diveintosystems.org/book/Appendix1/arrays_strings.html#_array_access_methods)16.5.2. 数组访问方法

Java provides multiple ways to access elements in its arrays. C, however, supports only indexing, as described earlier. Valid index values range from 0 to the capacity of the array minus 1. Here are some examples:

Java 提供了多种方法来访问其数组中的元素。但是，如前所述，C 仅支持索引。有效索引值的范围是从 0 到数组容量减 1。以下是一些示例：

```c
int i, num;
int arr[10];  // declare an array of ints, with a capacity of 10

num = 6;      // keep track of how many elements of arr are used

// initialize first 5 elements of arr (at indices 0-4)
for (i=0; i < 5; i++) {
    arr[i] = i * 2;
}

arr[5] = 100; // assign the element at index 5 the value 100
```

This example declares the array with a capacity of 10 (it has 10 elements), but it only uses the first six (our current collection of values is size 6, not 10). It’s often the case when using statically declared arrays that some of an array’s capacity will remain unused. As a result, we need another program variable to keep track of the actual size (number of elements) in the array (`num` in this example).

此示例声明的数组容量为 10（它有 10 个元素），但只使用了前 6 个（我们当前的值集合大小为 6，而不是 10）。使用静态声明的数组时，通常会出现数组部分容量未使用的情况。因此，我们需要另一个程序变量来跟踪数组中的实际大小（元素数量）（此示例中为 `num`）。

Java and C differ in their error-handling approaches when a program attempts to access an invalid index. Java throws a `java.lang.ArrayIndexOutOfBoundsException` exception if an invalid index value is used to access elements in an array. In C, it’s up to the programmer to ensure that their code uses only valid index values when indexing into arrays. As a result, for code like the following that accesses an array element beyond the bounds of the allocated array, the program’s runtime behavior is undefined:

当程序尝试访问无效索引时，Java 和 C 的错误处理方法有所不同。如果使用无效索引值访问数组中的元素，Java 会抛出 `java.lang.ArrayIndexOutOfBoundsException` 异常。在 C 中，程序员需要确保他们的代码在索引数组时仅使用有效的索引值。因此，对于像下面这样访问分配数组边界之外的数组元素的代码，程序的运行时行为是未定义的：

```c
int array[10];    // an array of size 10 has valid indices 0 through 9

array[10] = 100;  // 10 is not a valid index into the array
```

The C compiler is happy to compile code that accesses array positions beyond the bounds of the array; there is no bounds checking by the compiler or at runtime. As a result, running this code can lead to unexpected program behavior (and the behavior might differ from run to run). It can lead to your program crashing, it can change another variable’s value, or it might have no effect on your program’s behavior. In other words, this situation leads to a program bug that might or might not show up as unexpected program behavior. Thus, as a C programmer, it’s up to you to ensure that your array accesses refer to valid positions!

C 编译器很乐意编译访问数组边界之外的数组位置的代码；编译器或运行时不会进行边界检查。因此，运行此代码可能会导致意外的程序行为（并且每次运行的行为可能不同）。它可能会导致程序崩溃，可能会更改另一个变量的值，也可能对程序的行为没有影响。换句话说，这种情况会导致程序错误，可能会也可能不会显示为意外的程序行为。因此，作为 C 程序员，您必须确保您的数组访问引用有效位置！
### [](https://diveintosystems.org/book/Appendix1/arrays_strings.html#_arrays_and_functions)16.5.3. 数组和函数

The semantics of passing arrays to functions in C is similar to that of passing arrays to functions in Java: the function can alter the elements in the passed array. Here’s an example function that takes two parameters, an `int` array parameter (`arr`), and an `int` parameter (`size`):

在 C 语言中将数组传递给函数的语义与在 Java 语言中将数组传递给函数的语义类似：函数可以改变传递的数组中的元素。下面是一个接受两个参数的示例函数，一个 `int` 数组参数 (`arr`)和一个 `int` 参数 (`size`)：

```c
void print_array(int arr[], int size) {
    int i;
    for (i = 0; i < size; i++) {
        printf("%d\n", arr[i]);
    }
}
```

The `[]` after the parameter name tells the compiler that the type of the parameter `arr` is **array of int**, not `int` like the parameter `size`. In Chapter 2 we show an alternate syntax for specifying array parameters. The capacity of the array parameter `arr` isn’t specified: `arr[]` means that this function can be called with an array argument of any capacity. Because there is no way to get an array’s size or capacity just from the array variable, functions that are passed arrays almost always also have a second parameter that specifies the array’s size (the `size` parameter in the preceding example).

参数名称后面的 `[]` 告诉编译器参数 `arr` 的类型是**int 数组**，而不是像参数 `size` 那样的 `int`。在第 2 章中，我们展示了指定数组参数的另一种语法。数组参数 `arr` 的容量未指定：`arr[]` 表示可以使用任意容量的数组参数调用此函数。因为无法仅从数组变量中获取数组的大小或容量，所以传递数组的函数几乎总是还有第二个参数来指定数组的大小（前面示例中的 `size` 参数）。

To call a function that has an array parameter, pass **the name of the array** as the argument. Here is a C code snippet with example calls to the `print_array` function:
要调用具有数组参数的函数，请将**数组名称**作为参数传递。下面是一段 C 代码片段，其中包含对 `print_array` 函数的示例调用：
```c
int some[5], more[10], i;

for (i = 0; i < 5; i++) {  // initialize the first 5 elements of both arrays
    some[i] = i * i;
    more[i] = some[i];
}

for (i = 5; i < 10; i++) { // initialize the last 5 elements of "more" array
    more[i] = more[i-1] + more[i-2];
}

print_array(some, 5);    // prints all 5 values of "some"
print_array(more, 10);   // prints all 10 values of "more"
print_array(more, 8);    // prints just the first 8 values of "more"
```

In C, the name of the array variable is equivalent to the **base address** of the array (that is, the memory location of its 0th element). Due to C’s _pass by value_ function call semantics, when you pass an array to a function, each element of the array is _not_ individually passed to the function. In other words, the function isn’t receiving a copy of each array element. Instead, an array parameter gets the _value of the array’s base address_. This behavior implies that when a function modifies the elements of an array that was passed as a parameter, the changes _will_ persist when the function returns. For example, consider this C program snippet:
在 C 语言中，数组变量的名称相当于数组的**基地址**（即其第 0 个元素的内存位置）。由于 C 的 _按值传递_ 函数调用语义，当你将数组传递给函数时，数组的每个元素 _不会_ 单独传递给函数。换句话说，函数不会收到每个数组元素的副本。相反，数组参数会获取 _数组基地址的值_ 。此行为意味着当函数修改作为参数传递的数组的元素时，这些更改将在函数返回时保留。例如，考虑以下 C 程序片段：

```c
void test(int a[], int size) {
    if (size > 3) {
        a[3] = 8;
    }
    size = 2; // changing parameter does NOT change argument
}

int main(void) {
    int arr[5], n = 5, i;

    for (i = 0; i < n; i++) {
        arr[i] = i;
    }

    printf("%d %d", arr[3], n);  // prints: 3 5

    test(arr, n);
    printf("%d %d", arr[3], n);  // prints: 8 5

    return 0;
}
```

The call in `main` to the `test` function is passed the argument `arr`, whose value is the base address of the `arr` array in memory. The parameter `a` in the test function gets a copy of this base address value. In other words, parameter `a` _refers to the same array storage locations as its argument_, `arr`. As a result, when the test function changes a value stored in the `a` array (`a[3] = 8`), it affects the corresponding position in the argument array (`arr[3]` is now 8). The reason is that the value of `a` is the base address of `arr`, and the value of `arr` is the base address of `arr`, so both `a` and `arr` refer to the same array (the same storage locations in memory)! [Figure 1](https://diveintosystems.org/book/Appendix1/arrays_strings.html#FigCArrayStack) shows the stack contents at the point in the execution just before the test function returns.

在 `main` 中对 `test` 函数的调用传递了参数 `arr`，其值是内存中 `arr` 数组的基地址。测试函数中的参数 `a` 获取此基地址值的副本。换句话说，参数 `a` 与其参数 `arr` 指向相同的数组存储位置。因此，当测试函数更改存储在 `a` 数组中的值（`a[3] = 8`）时，它会影响参数数组中的相应位置（`arr[3]` 现在为 8）。原因是 `a` 的值是 `arr` 的基地址，而 `arr` 的值是 `arr` 的基地址，因此 `a` 和 `arr` 都引用同一个数组（内存中相同的存储位置）！ [图 1](https://diveintosystems.org/book/Appendix1/arrays_strings.html#FigCArrayStack) 显示了测试函数返回之前执行过程中的堆栈内容。

![A stack with two frames: main at the bottom and test on the top. main has two variables, an integer n (5) and an array storing values 0, 1, 2, 8, and 4.  Test also has two values, an integer size (2) and an array parameter arr that stores the base memory address of the array in main’s stack frame.](https://diveintosystems.org/book/Appendix1/_images/arraystack.png)

Figure 1. The stack contents for a function with an array parameter
图 1. 具有数组参数的函数的堆栈内容

Parameter `a` is passed the value of the base address of the array argument `arr`, which means they both refer to the same set of array storage locations in memory. We indicate this with the arrow from `a` to `arr`. Values that get modified by the function `test` are highlighted. Changing the value of the parameter `size` does _not_ change the value of its corresponding argument `n`, but changing the value of one of the elements referred to by `a` (for example, `a[3] = 8`) does affect the value of the corresponding position in `arr`.

参数`a`传递的是数组参数`arr`基地址的值，这意味着它们都引用内存中同一组数组存储位置。我们用从`a`到`arr`的箭头表示这一点。函数`test`修改的值已突出显示。更改参数`size`的值不会改变其对应参数“n”的值，但更改`a`引用的元素之一的值（例如，`a[3] = 8`）会影响`arr`中相应位置的值。
### [](https://diveintosystems.org/book/Appendix1/arrays_strings.html#_introduction_to_strings_and_the_c_string_library)16.5.4. 字符串和 C 字符串库简介

Java implements a `String` class and provides a rich interface for using strings. C does not define a string type. Instead, strings are implemented as arrays of `char` values. Not every character array is used as a C string, but every C string is a character array.

Java 实现了 `String` 类并提供了使用字符串的丰富接口。C 没有定义字符串类型。相反，字符串被实现为 `char` 值数组。并非每个字符数组都用作 C 字符串，但每个 C 字符串都是字符数组。

Recall that arrays in C might be defined with a larger size than a program ultimately uses. For example, we saw earlier in the section ["Array Access Methods"](https://diveintosystems.org/book/Appendix1/arrays_strings.html#_array_access_methods) that we might declare an array of size 10 but only use the first six positions. This behavior has important implications for strings: we can’t assume that a string’s length is equal to that of the array that stores it. For this reason, strings in C must end with a special character value, the **null character** (`'\0'`), to indicate the end of the string.

回想一下，C 语言中数组的定义大小可能比程序最终使用的大小要大。例如，我们之前在  [“数组访问方法”](https://diveintosystems.org/book/Appendix1/arrays_strings.html#_array_access_methods) 一节中看到，我们可能声明一个大小为 10 的数组，但只使用前六个位置。这种行为对字符串有重要影响：我们不能假设字符串的长度等于存储它的数组的长度。因此，C 语言中的字符串必须以特殊字符值(**空字符**(`'\0'`))结尾，以指示字符串的结尾。

Strings that end with a null character are said to be **null-terminated**. Although all strings in C _should_ be null-terminated, failing to properly account for null characters is a common source of errors for novice C programmers. When using strings, it’s important to keep in mind that your character arrays must be declared with enough capacity to store each character value in the string plus the null character (`'\0'`). For example, to store the string `"hi"`, you need an array of at least three chars (one to store `'h'`, one to store `'i'`, and one to store `'\0'`).
以空字符结尾的字符串被称为**以空字符终止**。尽管 C 中的所有字符串都应该以空字符终止，但未能正确处理空字符是 C 程序员新手常犯的错误。使用字符串时，请务必记住，字符数组必须声明为具有足够的容量来存储字符串中的每个字符值加上空字符 (`'\0'`)。例如，要存储字符串`"hi"`，您需要一个至少包含三个字符的数组（一个用于存储`'h'`，一个用于存储`'i'`，一个用于存储`'\0'`）。

Because strings are commonly used, C provides a string library that contains functions for manipulating strings. Programs that use these string library functions need to include the `string.h` header.
由于字符串的使用十分普遍，C 语言提供了一个字符串库，其中包含用于操作字符串的函数。使用这些字符串库函数的程序需要包含 `string.h` 头文件。

The C string library provides some similar functionality to the Java `String` class for manipulating string values. However, in C the program is responsible for ensuring that strings passed to the C string library are well-formed (null terminated char arrays) and that passed char arrays have enough capacity for the library function. Java hides these details from the programmer, and thus the programmer does not need to think about these when using strings in their Java program.

C 字符串库提供了一些与 Java `String` 类类似的功能，用于操作字符串值。但是在 C 中，程序负责确保传递给 C 字符串库的字符串格式正确（以空字符结尾的字符数组），并且传递的字符数组具有足够的容量供库函数使用。Java 向程序员隐藏了这些细节，因此程序员在 Java 程序中使用字符串时无需考虑这些细节。

When printing the value of a string with `printf`, use the `%s` placeholder in the format string. The `printf` function will print all the characters in the array argument until it encounters the `'\0'` character. Similarly, string library functions often either locate the end of a string by searching for the `'\0'` character or add a `'\0'` character to the end of any string that they modify.

使用 `printf` 打印字符串的值时，请在格式字符串中使用 `%s` 占位符。`printf` 函数将打印数组参数中的所有字符，直到遇到 `'\0'` 字符。同样，字符串库函数通常通过搜索 `'\0'` 字符来找到字符串的末尾，或者在它们修改的任何字符串的末尾添加 `'\0'` 字符。

Here’s an example program that uses strings and string library functions:
这是一个使用字符串和字符串库函数的示例程序：

```c
#include <stdio.h>
#include <string.h>   // include the C string library

int main(void) {
    char str1[10];
    char str2[10];
    int len;

    str1[0] = 'h';
    str1[1] = 'i';
    str1[2] = '\0';

    len = strlen(str1);

    printf("%s %d\n", str1, len);  // prints: hi 2

    strcpy(str2, str1);     // copies the contents of str1 to str2
    printf("%s\n", str2);   // prints:  hi

    strcpy(str2, "hello");  // copy the string "hello" to str2
    len = strlen(str2);
    printf("%s has %d chars\n", str2, len);   // prints: hello has 5 chars
}
```

The `strlen` function in the C string library returns the number of characters in its string argument. A string’s terminating null character doesn’t count as part of the string’s length, so the call to `strlen(str1)` returns 2 (the length of the string `"hi"`). The `strcpy` function copies one character at a time from a source string (the second parameter) to a destination string (the first parameter) until it reaches a null character in the source.

C 字符串库中的 `strlen` 函数返回其字符串参数中的字符数。字符串的终止空字符不计入字符串长度，因此对 `strlen(str1)` 的调用返回 2（字符串 `"hi"` 的长度）。 `strcpy` 函数每次将一个字符从源字符串（第二个参数）复制到目标字符串（第一个参数），直到到达源中的空字符。

Note that most C string library functions expect the call to pass in a character array that has enough capacity for the function to perform its job. For example, you wouldn’t want to call `strcpy` with a destination string that isn’t large enough to contain the source; doing so will lead to undefined behavior in your program!

请注意，大多数 C 字符串库函数都要求调用时传入一个字符数组，该数组具有足够的容量供函数执行其任务。例如，您不会希望使用大小不足以包含源字符串的目标字符串来调用`strcpy`；这样做会导致程序中出现未定义的行为！

C string library functions also require that string values passed to them are correctly formed, with a terminating `'\0'` character. It’s up to you as the C programmer to ensure that you pass in valid strings for C library functions to manipulate. Thus, in the call to `strcpy` in the preceding example, if the source string (`str1`) was not initialized to have a terminating `'\0'` character, `strcpy` would continue beyond the end of the `str1` array’s bounds, leading to undefined behavior that could cause it to crash.

C 字符串库函数还要求传递给它们的字符串值格式正确，并以 `'\0'` 结尾。作为 C 程序员，您必须确保传入的字符串对 C 库函数有效。因此，在上面的示例中对 `strcpy` 的调用中，如果源字符串(`str1`)未初始化为具有终止 `'\0'` 字符，则 `strcpy` 将继续超出 `str1` 数组边界的末尾，从而导致未定义的行为，并可能导致其崩溃。


> [!NOTE] 
> The previous example uses the `strcpy` function safely. In general, though, `strcpy` poses a security risk because it assumes that its destination is large enough to store the entire string, which may not always be the case (for example, if the string comes from user input).
> 
> We chose to show `strcpy` now to simplify the introduction to strings, but we illustrate safer alternatives in [Section 2.6](https://diveintosystems.org/book/C2-C_depth/strings.html#_strings_and_the_string_library).


> [!NOTE] 
> 前面的示例安全地使用了`strcpy`函数。但一般来说，`strcpy`会带来安全风险，因为它假定其目标足够大，可以存储整个字符串，但情况可能并非总是如此（例如，如果字符串来自用户输入）。
> 
> 我们现在选择展示`strcpy`以简化对字符串的介绍，但我们在[第 2.6 节](https://diveintosystems.org/book/C2-C_depth/strings.html#_strings_and_the_string_library)中说明了更安全的替代方案。


In Chapter 2, we discuss [C strings and the C string library](https://diveintosystems.org/book/C2-C_depth/strings.html#_strings_and_the_string_library) in more detail.
在第 2 章中，我们更详细地讨论了 [C 字符串和 C 字符串库](https://diveintosystems.org/book/C2-C_depth/strings.html#_strings_and_the_string_library)。