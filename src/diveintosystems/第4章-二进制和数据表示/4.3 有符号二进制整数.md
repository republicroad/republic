So far, we’ve limited the discussion of binary numbers to _unsigned_ (strictly non-negative) integers. This section presents an alternative interpretation of binary that incorporates negative numbers. Given that a variable has finite storage space, a signed binary encoding must distinguish between negative values, zero, and positive values. Manipulating signed numbers additionally requires a procedure for negating a number.
到目前为止，我们将二进制数的讨论限制为 _无符号_（严格非负）整数。本节介绍了包含负数的二进制的另一种解释。鉴于变量的存储空间有限，有符号二进制编码必须区分负值、零和正值。操作带符号的数字还需要一个对数字取反的过程。

A signed binary encoding must divide bit sequences between negative and non-negative values. In practice, systems designers build _general-purpose_ systems, so a 50% / 50% split is a good middle-of-the-road choice. Therefore, the signed number encodings that this chapter presents represent an equal number of negative and non-negative values.
有符号二进制编码必须将位序列划分为负值和非负值。在实践中，系统设计师构建_通用_系统，因此 50% / 50% 的分割是一个不错的中间选择。因此，本章介绍的有符号数编码表示相同数量的负值和非负值。


> [!NOTE] Non-Negative versus Positive
> Note that there’s a subtle but important difference between _non-negative_ and _positive_. The set of strictly positive values excludes zero, whereas the non-negative set includes zero. Even after dividing the available bit sequences 50% / 50% between negative and non-negative values, one of the non-negative values must still be reserved for zero. Thus, with a fixed number of bits, a number system may end up representing more negative values than positive values (e.g., in the two’s complement system).


> [!NOTE] 非负与正
> 请注意，_非负_ 和 _正_ 之间存在微妙但重要的区别。严格正值集合不包括零，而非负值集合包括零。即使将可用位序列在负值和非负值之间划分为 50% / 50%，非负值之一仍必须保留为零。因此，在位数固定的情况下，数字系统最终可能会表示比正值更多的负值（例如，在二进制补码(two’s complement system)系统中）。

Signed number encodings use one bit to distinguish between the sets of _negative_ numbers and _non-negative_ numbers. By convention, the left-most bit indicates whether a number is negative (1) or non-negative (0). This leftmost bit is known as the **high-order bit** or the **most significant bit**.

有符号数编码使用一位来区分 _负_ 数集和 _非负_ 数集。按照惯例，最左边的位指示数字是负数 (1) 还是非负数 (0)。最左边的位称为**高位**或**最高有效位**。

This chapter presents two potential signed binary encodings — _signed magnitude_ and _two’s complement_. Even though only one of these encodings (two’s complement) is still used in practice, comparing them will help to illustrate their important characteristics.
本章介绍了两种可能的有符号二进制编码 — _有符号量值_和_二进制补码_。尽管在实践中仅使用其中一种编码（二进制补码），但对它们进行比较将有助于说明它们的重要特征。

### 4.3.1. Signed Magnitude有符号量值

The **signed magnitude** representation treats the high-order bit exclusively as a sign bit. That is, whether the high-order bit is a 0 or a 1 does not affect the absolute value of the number, it _only_ determines whether the value is positive (high-order bit 0) or negative (high-order bit 1). Compared to two’s complement, signed magnitude makes the decimal conversion and negation procedures relatively straightforward:

- To compute a decimal value for an _N_-bit signed magnitude sequence, compute the value of digits d0 through dN-2 using the familiar [unsigned method](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers). Then, check the most significant bit, dN-1: if it’s 1, the value is negative; otherwise it isn’t.
    
- To negate a value, simply flip the most significant bit to change its sign.
    

**有符号量值**（**signed magnitude**）表示将高阶位专门视为符号位。也就是说，高位是 0 还是 1 并不影响数字的绝对值，它只决定该值是正（高位 0）还是负（高位 1）。与二进制补码相比，带符号的大小使得十进制转换和求反过程相对简单：

- 要计算 _N_ 位有符号量值序列的十进制值，请使用熟悉的[无符号方法](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers) 计算数字 d0 到 dN-2 的值。然后，检查最高有效位dN-1：如果为1，则值为负；如果为1，则值为负。否则就不是。
- 要对某个值求反，只需翻转最高有效位即可更改其符号。


> [!NOTE] Negation Misconception
> Signed magnitude is presented purely for pedagogical purposes. Although it was used by some machines in the past (e.g., [IBM’s 7090](https://en.wikipedia.org/wiki/IBM_7090) in the 1960s), no modern systems use signed magnitude to represent integers (although a similar mechanism _is_ part of the standard for storing [floating-point values](https://en.wikipedia.org/wiki/Single-precision_floating-point_format)).
> 
> Unless you’re explicitly asked to consider signed magnitude, you should _not_ assume that flipping the first bit of a binary number will negate that number’s value on a modern system.

> [!NOTE] 负值误解（Negation Misconception）
> 带符号的量值纯粹出于教学目的。尽管过去的一些机器（例如 20 世纪 60 年代的 [IBM 的 7090](https://en.wikipedia.org/wiki/IBM_7090)）使用了它），但没有现代系统使用有符号大小来表示整数（尽管类似的机制 _是_ 存储标准的一部分[浮点值](https://en.wikipedia.org/wiki/Single- precision_floating-point_format))。
> 
> 除非明确要求您考虑带符号的大小，否则您不应该假设翻转二进制数的第一位会在现代系统上得到该数字的负数值。


[Figure 1](https://diveintosystems.org/book/C4-Binary/signed.html#FigSignedMagnitude) shows how four-bit signed magnitude sequences correspond to decimal values. At first glance, signed magnitude might seem attractive due to its simplicity. Unfortunately, it suffers from two major drawbacks that make it unappealing. The first is that it presents _two_ representations of zero. For example, with four bits, signed magnitude represents both _zero_ (0b0000) and _negative zero_ (0b1000). Consequently, it poses a challenge to hardware designers because the hardware will need to account for two possible binary sequences that are numerically equal despite having different bit values. The hardware designer’s job is much easier with just one way of representing such an important number.

[图 1](https://diveintosystems.org/book/C4-Binary/signed.html#FigSignedMagnitude) 显示四位有符号量值序列如何与十进制值相对应。乍一看，有符号量值可能因其简单性而显得很有吸引力。不幸的是，它有两个主要缺点，使其没有吸引力。第一个是它呈现了 _两个_ 零的表示形式。例如，对于四位，带符号的量值表示 _零_ (0b0000) 和 _负零_ (0b1000)。因此，它给硬件设计者带来了挑战，因为硬件需要考虑两个可能的二进制序列，尽管它们具有不同的位值，但它们在数值上相等。只需用一种方式来表示如此重要的数字，硬件设计师的工作就会容易得多。

![A circle with non-negative values on one side ranging from 0b0000 (0) to 0b0111 (7).  The other side holds 0b1000 (-0) to 0b1111 (-7).](https://diveintosystems.org/book/C4-Binary/_images/SignedMagnitude.png)

Figure 1. A logical layout of signed magnitude values for bit sequences of length four.
图 1. 长度为 4 的位序列的带符号量值的逻辑布局。

The other drawback of signed magnitude is that it exhibits an inconvenient discontinuity between negative values and zero. While we’ll cover [overflow](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow) in more detail later, adding 1 to the four-bit sequence 0b1111 "rolls over" back to 0b0000. With signed magnitude, this effect means 0b1111 (-7) + 1 might be mistaken for 0 rather than the expected -6. This problem is solvable, but the solution again complicates the design of the hardware, essentially turning any transition between negative and non-negative integers into a special case that requires extra care.

有符号量值的另一个缺点是它在负值和零之间表现出不方便的不连续性。虽然我们稍后会更详细地介绍[溢出](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow)，但向四位序列 0b1111 添加 1 会“翻转”回 0b0000。对于带符号的量值，此效应意味着 0b1111 (-7) + 1 可能会被误认为 0 而不是预期的 -6。这个问题是可以解决的，但该解决方案再次使硬件设计变得复杂，本质上将负整数和非负整数之间的任何转换变成需要额外小心的特殊情况。

For these reasons, signed magnitude has largely disappeared in practice, and two’s complement reigns supreme.
由于这些原因，符号大小在实践中基本上消失了，而补码占据了主导地位。

### 4.3.2. 补码(Two’s Complement)

**Two’s complement** encoding solves signed magnitude’s problems in an elegant way. Like signed magnitude, the high-order bit of a two’s complement number indicates whether or not the value should be interpreted as negative. In contrast though, the high-order bit also affects the value of the number. So, how can it do both?
**二进制补码**编码以一种优雅的方式解决了有符号幅度的问题。与带符号的大小一样，二进制补码数的高位指示该值是否应解释为负数。但相比之下，高位也会影响数字的值。那么，如何才能做到这两点呢？

Computing a decimal value for an _N_-bit two’s complement number is similar to the familiar [unsigned method](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers), except the high-order bit’s contribution to the overall value is negated. That is, for an _N_-bit two’s complement sequence, instead of the first bit contributing dN-1 × 2N-1 to the sum, it contributes **-dN-1** × 2N-1 (note the negative sign). Therefore, if the most significant bit is a 1, the overall value will be negative because that first bit contributes the largest absolute value to the sum. Otherwise, the first bit contributes nothing to the sum, and the result is non-negative. The full formula is:
计算 _N_ 位二进制补码的十进制值类似于熟悉的[无符号方法](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers)，只不过高位对整体值的贡献被否定。也就是说，对于 _N_ 位二进制补码序列，不是第一位为总和贡献 dN-1 × 2N-1，而是贡献 **-d<sub>N-1</sub> × 2<sup>N-1</sup>** （注意负号）。因此，如果最高有效位是 1，则总值将为负，因为第一位对总和贡献的绝对值最大。否则，第一位对总和没有任何贡献，并且结果为非负数。完整的公式是：

> **-** (d<sub>N-1</sub> × 2<sup>N-1</sup>)    +    (d<sub>N-2</sub> × 2<sup>N-2</sup>)    +    …​    +    (d<sub>2</sub> × 2<sup>2</sup>)    +    (d<sub>1</sub> × 2<sup>1</sup>)    +    (d<sub>0</sub> × 2<sup>0</sup>)
> ^ note the leading negative sign for just the first term!

[Figure 2](https://diveintosystems.org/book/C4-Binary/signed.html#FigTwosComplement) illustrates the layout of four-bit sequences in two’s complement. This definition encodes just one representation of zero — a sequence of bits that are all 0’s. With only a single _zero_ sequence, two’s complement represents one more negative value than positive. Using four-bit sequences as an example, two’s complement represents a minimum value of 0b1000 (-8), but a maximum value of only 0b0111 (7). Fortunately, this quirk doesn’t hinder hardware design and rarely causes problems for applications.
[图 2](https://diveintosystems.org/book/C4-Binary/signed.html#FigTwosComplement) 展示了二进制补码形式的四位序列的布局。该定义仅编码零的一种表示形式——全为 0 的位序列。仅使用单个 _zero_ 序列，二进制补码表示的负值比正值多一个。以四位序列为例，二进制补码表示最小值为 0b1000（-8），但最大值仅为 0b0111（7）。幸运的是，这种怪癖不会妨碍硬件设计，也很少会给应用程序带来问题。

![A circle with non-negative values on one side ranging from 0b0000 (0) to 0b0111 (7).  The other side holds 0b1111 (-1) to 0b1000 (-8).](https://diveintosystems.org/book/C4-Binary/_images/TwosComplement.png)

Figure 2. A logical layout of two’s complement values for bit sequences of length four.
图 2. 长度为 4 的位序列的二进制补码值的逻辑布局。

Compared to signed magnitude, two’s complement also simplifies the transition between negative numbers and zero. Regardless of the number of bits used to store it, a two’s complement number consisting of all ones will always hold the value -1. Adding 1 to a bit sequence of all 1’s "rolls over" to zero, which makes two’s complement convenient, since -1 + 1 _should_ produce zero.
与有符号的大小相比，二进制补码还简化了负数和零之间的转换。无论用于存储它的位数有多少，由全 1 组成的二进制补码数将始终保持值 -1。将 1 添加到全 1 的位序列“翻转”为零，这使得补码变得很方便，因为 -1 + 1 _应该_ 产生零。
#### 负值与取反

Negating a two’s complement number is slightly trickier than negating a signed magnitude value. To negate an _N_-bit value, determine its **complement** with respect to 2N (this is where the encoding’s name comes from). In other words, to negate an _N_-bit value _X_, find a bit sequence _Y_ (_X_'s complement) such that _X_ + _Y_ = 2N.
对二进制补码取反比对带符号的数值取反要稍微棘手一些。要否定 _N_ 位值，请确定其相对于 2N 的**补码**（这就是编码名称的来源）。换句话说，要对 _N_ 位值 _X_ 求反，请找到一个位序列 _Y_（_X_ 的补码），使得 _X_ + _Y_ = 2N。

Fortunately, there’s a quick shortcut for negating a two’s complement number in practice: flip all the bits and add one. For example, to negate the eight-bit value 13, first [determine the binary value of 13](https://diveintosystems.org/book/C4-Binary/conversion.html#_converting_from_decimal). Because 13 is the sum of 8, 4, and 1, set the bits in positions 3, 2, and 0:
幸运的是，在实践中，有一个快速的捷径可以对二进制补码求反：翻转所有位并加一。例如，要对八位值 13 求反，首先[确定 13 的二进制值](https://diveintosystems.org/book/C4-Binary/conversion.html#_converting_from_decimal)。因为 13 是 8、4 和 1 的和，所以将位设置在位置 3、2 和 0：

```bash
00001101  (decimal 13)
```
Next, "flip the bits" (change all zeros to ones, and vice versa):
接下来，“翻转位”（将所有零更改为一，反之亦然）：

```bash
11110010
```

Finally, adding one yields 0b11110011. Sure enough, applying the formula for interpreting a two’s complement bit sequence shows that the value is -13:
最后，加 1 得到 0b11110011。果然，应用解释二进制补码位序列的公式显示该值为 -13：

-(1 × 2<sup>7</sup>)    +    (1 × 2<sup>6</sup>)    +    (1 × 2<sup>5</sup>)    +    (1 × 2<sup>4</sup>)    +    (0 × 2<sup>3</sup>)    +    (0 × 2<sup>2</sup>)    +    (1 × 2<sup>1</sup>)    +    (1 × 2<sup>0</sup>)

  =    -128 + 64 + 32 + 16 + 0 + 0 + 2 + 1    =    -13

If you’re curious as to why this seemingly magical shortcut works, consider the eight-bit negation of 13 more formally. To find 13’s complement, solve 0b00001101 (13) + _Y_ = 0b100000000 (28, which requires an extra bit to represent). The equation can be rearranged as _Y_ = 0b100000000 - 0b00001101. This is clearly now a subtraction problem:
如果您好奇为什么这个看似神奇的捷径有效，请更正式地考虑 13 的八位求反。要找到 13 的补码，请求解 0b00001101 (13) + _Y_ = 0b100000000（2<sup>8</sup>，需要额外的位来表示）。该方程可以重新排列为 _Y_ = 0b100000000 - 0b00001101。这显然是一个减法问题：

```bash
 100000000  (256)
- 00001101   (13)
```

While such a subtraction might seem daunting, we can express it in a way that’s easier to compute as (0b011111111 + 1) - 0b00001101. Note that this change simply expresses 28 (256) as (255 + 1). After that change, the arithmetic looks like:
虽然这样的减法可能看起来令人畏惧，但我们可以用一种更容易计算的方式将其表示为 (0b011111111 + 1) - 0b00001101。请注意，此更改只是将 28 (256) 表示为 (255 + 1)。更改后，算术如下所示：

```bash
 011111111  (255)  + 00000001  (1)
- 00001101   (13)
```

As it turns out, for _any_ bit value _b_, 1 - _b_ is equivalent to "flipping" that bit. Thus, the entire subtraction in the preceding example can be reduced to just flipping all the bits of the lower number. All that’s left is to add the remaining +1 from expressing 256 as 255 + 1. Putting it all together, we can simply flip a value’s bits and add one to compute its complement!
事实证明，对于任何位值 _b_，1 - _b_ 相当于“翻转”该位。因此，前面示例中的整个减法可以简化为仅翻转较低数字的所有位。剩下的就是将 256 表示为 255 + 1 时剩下的 +1 相加。将它们放在一起，我们可以简单地翻转一个值的位并加 1 来计算其补码！


> [!NOTE] C Programming With Signed versus Unsigned Integers
> In addition to allocating space, declaring variables in C also tells the compiler how you’d like the variable to be interpreted. When you declare an `int`, the compiler interprets the variable as a signed two’s complement integer. To allocate an unsigned value, declare an `unsigned int`.
> 
>  The distinction is also relevant to C in other places, like the `printf` function. As this chapter has been stressing throughout, a bit sequence can be interpreted in different ways! With `printf`, the interpretation depends on the formatting placeholder you use. For example:
>  
>```
>#include <stdio.h>
>
>int main(void) {
 >   int example = -100;
>
 >   /* Print example int using both signed and unsigned placeholders. */
    >printf("%d  %u\n", example, example);
>
  >  return 0;
>}
>```
>  
>  Even though this code passes `printf` the same variable (`example`) twice, it prints `-100 4294967196`. Be careful to interpret your values correctly!
>



> [!NOTE] C Programming With Signed versus Unsigned Integers
> 除了分配空间之外，在 C 中声明变量还可以告诉编译器您希望如何解释该变量。当您声明`int`时，编译器会将该变量解释为带符号的二进制补码整数。要分配无符号值，请声明`unsigned int`。
> 
>  这种区别在其他地方也与 C 相关，例如 `printf` 函数。正如本章自始至终强调的那样，一个位序列可以用不同的方式解释！对于 `printf`，解释取决于您使用的格式占位符。例如：
>  
>```
>#include <stdio.h>
>
>int main(void) {
 >   int example = -100;
>
 >   /* Print example int using both signed and unsigned placeholders. */
    >printf("%d  %u\n", example, example);
>
  >  return 0;
>}
>```
>  
>  即使此代码将同一变量（`example`）传递给`printf`两次，它也会打印`-100 4294967196`。小心正确地解释变量的值！



#### 符号位扩展Sign Extension

Occasionally, you may find yourself wanting to perform an arithmetic operation on two numbers that are stored using different numbers of bits. For example, in C you may want to add a 32-bit `int` and a 16-bit `short`. In such cases, the smaller number needs to be **sign extended**, which is a fancy way of saying that its most significant bit gets repeated as many times as necessary to extend the length of the bit sequence to the target length. Though the compiler will take care of wrangling the bits for you in C, it’s still helpful to understand how the process works.
有时，您可能会发现自己想要对使用不同位数存储的两个数字执行算术运算。例如，在 C 中，您可能想要添加一个 32 位`int`和一个 16 位`short`。在这种情况下，较小的数字需要**符号扩展**，这是一种奇特的说法，它的最高有效位根据需要重复多次，以将位序列的长度扩展到目标长度。尽管编译器会在 C 语言中为您处理这些位，但了解该过程的工作原理仍然很有帮助。

For example, to extend the four-bit sequence 0b0110 (6) to an eight-bit sequence, take the high-order bit (0) and prepend it four times to produce the extended value: 0b**0000**0110 (still 6). Extending 0b1011 (-5) to an eight-bit sequence similarly takes the high-order bit (this time, 1) and prepends it four times to the resulting extended value: 0b**1111**1011 (still -5). To verify the correctness, consider how the value changes after adding each new bit:
例如，要将四位序列 0b0110 (6) 扩展为八位序列，请采用高位 (0) 并将其添加到前面四次以生成扩展值：0b**0000**0110（仍然是 6）。将 0b1011 (-5) 扩展为八位序列类似地采用高位（这次是 1）并将其四次添加到结果扩展值：0b**1111**1011（仍然是 -5）。要验证正确性，请考虑添加每个新位后值如何变化：

```bash
    0b1011 =                       -8 + 0 + 2 + 1  =  -5
   0b11011 =                  -16 + 8 + 0 + 2 + 1  =  -5
  0b111011 =             -32 + 16 + 8 + 0 + 2 + 1  =  -5
 0b1111011 =        -64 + 32 + 16 + 8 + 0 + 2 + 1  =  -5
0b11111011 =  -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1  =  -5
```

As evidenced by the examples, numbers that are non-negative (high-order bit of zero) remain non-negative after adding zeros to the front. Likewise, negatives (high-order bit of one) remain negative after prepending ones to extended values.
正如示例所证明的，非负数（高位零）在前面添加零后仍保持非负数。同样，负数（1 的高位）在将其添加到扩展值之后仍然为负数。


> [!NOTE] Unsigned Zero Extension
> For an unsigned value (e.g., a C variable explicitly declared with an `unsigned` qualifier), extending it to a longer bit sequence instead requires **zero extension**, since the `unsigned` qualifier prevents the value from ever being interpreted as negative. Zero extension simply prepends zeros to the high-order bits of the extended bit sequence. For example, 0b1110 (14 when interpreted as unsigned!) extends to 0b**0000**1110 despite the original leading 1.



> [!NOTE] 无符号零扩展(Unsigned Zero Extension)
> 对于无符号值（例如，使用无符号限定符显式声明的 C 变量），将其扩展为更长的位序列需要零扩展，因为无符号限定符可防止该值被解释为负数。零扩展只是将零前置到扩展位序列的高位位。例如，0b1110（当解释为无符号时为 14！）扩展为 0b00001110，尽管最初的前导是 1。
