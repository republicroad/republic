### 4.4.1. 加法

Recall that in a binary number, each digit holds only 0 or 1. Consequently, when adding two bits that are _both_ 1, the result _carries out_ to the next digit (e.g., 1 + 1 = 0b10, which requires two bits to represent). In practice, programs add multibit variables, where the result of one digit’s _carry out_ influences the next digit by _carrying in_.

回想一下，在二进制数中，每个数字只包含 0 或 1。因此，当将两个都是 1 的位相加时，结果会执行到下一位数字（例如，1 + 1 = 0b10，这需要两个位来表示）。在实践中，程序会添加多位变量，其中一位数字的结果 _进位_(_carry out_) 会通过 _进位_(_carrying in_) 影响下一位数字。

In general, when summing digits from two binary numbers (_A_ and _B_), there are _eight_ possible outcomes depending on the values of _DigitA_, _DigitB_, and a _Carryin_ from the previous digit. [Table 1](https://diveintosystems.org/book/C4-Binary/arithmetic_addition.html#TabBinarySum) enumerates the eight possibilities that may result from adding one pair of bits. The _Carryin_ column refers to a carry feeding into the sum from the previous digit, and the _Carryout_ column indicates whether adding the pair of digits will feed a carry out to the next digit.

一般来说，当对两个二进制数（_A_ 和 _B_）进行数字求和时，根据前一位数字的 _DigitA_、_DigitB_ 和 _Carryin_ 的值，有_八种_可能的结果。 [表 1](https://diveintosystems.org/book/C4-Binary/arithmetic_addition.html#TabBinarySum) 列举了添加一对位可能产生的八种可能性。 _Carryin_ 列是指从前一个数字向和中输入进位，_Carryout_ 列表示将这对数字相加是否会将进位输入到下一个数字中。



Table 1. The Eight Possible Outcomes of Adding Two Binary Digits (_A_ and _B_) with a Potential Carry In from the Previous Digit
表 1. 添加两个二进制数字（_A_ 和 _B_）以及可能从前一个数字进位(Carry In)的八种可能结果

|      Inputs       |      Inputs       |       Inputs       |   Outputs    |       Outputs       |
| :---------------: | :---------------: | :----------------: | :----------: | :-----------------: |
| Digit<sub>A</sub> | Digit<sub>B</sub> | Carry<sub>in</sub> | Result (Sum) | Carry<sub>out</sub> |
|         0         |         0         |         0          |      0       |          0          |
|         0         |         0         |         1          |      1       |          0          |
|         0         |         1         |         0          |      1       |          0          |
|         0         |         1         |         1          |      0       |          1          |
|         1         |         0         |         0          |      1       |          0          |
|         1         |         0         |         1          |      0       |          1          |
|         1         |         1         |         0          |      0       |          1          |
|         1         |         1         |         1          |      1       |          1          |


Consider the addition of two four-bit binary numbers. Start by lining up the numbers so that their corresponding digits match vertically, and then sum each corresponding digit in order, from the low-order digit (d0) to the high-order digit (d3). For example, adding 0b0010 + 0b1011:
考虑两个四位二进制数的相加。首先将数字排列起来，使其对应的数字垂直匹配，然后按从低位数字 (d0) 到高位数字 (d3) 的顺序将每个对应数字相加。例如，添加 0b0010 + 0b1011：

| Problem Setup                 | Worked Example                                                                                                                    |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| &nbsp&nbsp&nbsp0010<br>+ 1011 | &nbsp&nbsp&nbsp&nbsp&nbsp1    <- Carry the 1 from digit 1 into digit 2<br>&nbsp&nbsp&nbsp0010<br>      + 1011<br><br>Result: 1101 |

The example shows a 1 carrying from d1 into d2. This situation is analogous to adding two decimal digits that sum to a value larger than 9. For example, when adding 5 + 8 = 13, the resulting ones place contains 3, and a 1 carries into the tens place.
该示例显示 1 从 d1 传送到 d2。这种情况类似于将两个十进制数字相加，其总和大于 9。例如，当 5 + 8 = 13 相加时，结果个位包含 3，并且 1 进位到十位。

The first operand (0b0010) has a leading 0, so it represents 2 for both two’s complement and unsigned interpretations. The second operand (0b1011) represents -5 if interpreted as a signed two’s complement value. Otherwise, it represents 11 if interpreted as an unsigned value. Fortunately, the interpretation of the operands doesn’t affect the steps for computing the result. That is, the computed result (0b1101) represents either 13 (unsigned: 2 + 11) or -3 (signed: 2 + -5), both of which are correct depending on the interpretation of the second operand.
第一个操作数 (0b0010) 有一个前导 0，因此对于二进制补码和无符号解释来说，它都代表 2。如果将第二个操作数 (0b1011) 解释为带符号的二进制补码值，则表示 -5。否则，如果解释为无符号值，则表示 11。幸运的是，操作数的解释不会影响计算结果的步骤。也就是说，计算结果 (0b1101) 表示 13（无符号：2 + 11）或 -3（有符号：2 + -5），这两者都是正确的，具体取决于第二个操作数的解释。

More generally, a four-bit sequence represents values in the range [0, 15] when interpreted as _unsigned_. When interpreted as _signed_, it represents the range [-8, 7]. In the previous example, the result fits within the representable range either way, but we may not always be so lucky. For example, when adding 0b1100 (unsigned 12) + 0b0111 (7), the answer should be 19, but four bits can’t represent 19:
更一般地，当解释为 _无符号_ 时，四位序列表示范围 [0, 15] 内的值。当解释为 _signed_ 时，它表示范围 [-8, 7]。在前面的示例中，无论哪种方式，结果都符合可表示的范围，但我们可能并不总是那么幸运。例如，当添加0b1100（无符号12）+ 0b0111（7）时，答案应该是19，但四位不能代表19：

| Problem Setup                 | Worked Example                                                                                                                                                                                                |
| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| &nbsp&nbsp&nbsp1100<br>+ 0111 | &nbsp11     <- Carry a 1 from: digit 2 into digit 3, and<br>&nbsp&nbsp&nbsp1100                       &nbspdigit 3 out of the overall value<br>           +  0111<br><br>   Result:    0011<br>Carry out:   1 |

Note that the addition in this example carries a 1 from the most significant bit, a condition known as a **carry out** for the overall arithmetic operation. In this example, the carry out suggests that the arithmetic output needs an extra bit to store the intended result. However, when performing four-bit arithmetic, there’s nowhere to put the carry out’s extra bit, so the hardware simply drops or **truncates** it, leaving 0b0011 as the result. Of course, if the goal was to add 12 + 7, a result of 3 is likely to be surprising. The surprise is a consequence of _overflow_. We’ll explore how to detect overflow and why it produces the results that it does in a [later section](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow).

请注意，此示例中的加法从最高有效位开始携带 1，这种条件称为整个算术运算的 **执行**。在此示例中，进位表明算术输出需要额外的位来存储预期结果。然而，当执行四位算术时，没有地方可以放置进位的额外位，因此硬件只是丢弃或**截断**它，留下 0b0011 作为结果。当然，如果目标是加上12+7，那么3的结果可能会令人惊讶。令人惊讶的是 _溢出_(_overflow_) 的结果。我们将在[后面的部分](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow)中探讨如何检测溢出以及它为何会产生这样的结果。


> [!NOTE] 
> Multibit adder circuits also support a **carry in** that behaves like a carry into the rightmost digit (that is, it serves as the _Carryin_ input for d0). The carry in isn’t useful when performing addition — it’s implicitly set to 0, which is why it doesn’t appear in the preceding example. However, the carry in does become relevant for other operations that use adder circuitry, most notably [subtraction](https://diveintosystems.org/book/C4-Binary/arithmetic_subtraction.html#_subtraction).


> [!NOTE] 
> 多位加法器电路还支持**进位**，其行为类似于最右边数字的进位（即，它充当 d0 的_进位_ 输入）。进位在执行加法时没有用——它被隐式设置为 0，这就是为什么它没有出现在前面的示例中。然而，进位确实与使用加法器电路的其他操作相关，最值得注意的是[4.4.2. 减法](4.4.2.%20减法.md)。

