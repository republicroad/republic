### 4.4.2. 减法

Subtraction combines two familiar operations: negation and addition. In other words, subtracting 7 - 3 is equivalent to expressing the operation as 7 + (-3). This portrayal of subtraction aligns well with how the hardware behaves — a CPU already contains circuits for negation and addition, so it makes sense to reuse those circuits rather than build an entirely new subtractor. Recall that a simple procedure to negate a binary number is to [flip the bits and add one](https://diveintosystems.org/book/C4-Binary/signed.html#_negation).
减法结合了两种熟悉的运算：求反和加法。换句话说，减去 7 - 3 相当于将运算表示为 7 + (-3)。这种减法的描述与硬件的行为方式非常吻合——CPU 已经包含用于求反和加法的电路，因此重用这些电路而不是构建一个全新的减法器是有意义的。回想一下，对二进制数求反的一个简单过程是[取反并加一](https://diveintosystems.org/book/C4-Binary/signed.html#_negation)。

Consider the example 0b0111 (7) - 0b0011 (3), which starts by sending the 3 to a bit-flipping circuit. To get the "plus one," it takes advantage of the **carry in** to the adder circuit. That is, rather than carrying from one digit to another, subtraction feeds a _carry in_ to d0 of the adder. Setting the carry in to 1 increases the resulting "ones place" value by one, which is exactly what it needs to get the "plus one" part of the negation. Putting it all together, the example would look like the following:
考虑示例 0b0111 (7) - 0b0011 (3)，它首先将 3 发送到位翻转电路。为了获得“加一”，它利用了加法器电路的**进位**。也就是说，减法不是将一个数字传送到另一个数字，而是将 _进位_ 传送给加法器的 d0。将进位设置为 1 会将所得的“个位”值增加 1，这正是获得求反的“加一”部分所需的值。将所有内容放在一起，该示例将如下所示：

| Problem Setup                 | Converted to Addition                                                                                     | Worked Example                                                                                                                                                 |
| ----------------------------- | --------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| &nbsp&nbsp&nbsp0111<br>- 0011 | &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp1 (carry in)<br>&nbsp&nbsp&nbsp0111<br>+ 1100 (bits flipped) | &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp1 (carry in)<br>&nbsp&nbsp&nbsp0111<br>           + 1100 (bits flipped)<br><br>   Result:   0100<br>Carry out:  1 |

While the full result of the addition carries into an extra digit, the truncated result (0b0100) represents the expected result (4). Unlike the previous addition example, a carry out from the high-order bit is not necessarily indicative of an overflow problem for subtraction.
虽然加法的完整结果会带入一个额外的数字，但截断的结果 (0b0100) 表示预期结果 (4)。与前面的加法示例不同，从高位进位不一定表示减法存在溢出问题。

Performing subtraction as negation followed by addition also works when subtracting a negative value. For example, 7 - (-3) produces 10:
在减去负值时，先执行减法，然后执行加法也有效。例如，7 - (-3) 产生 10：

| Problem Setup                 | Converted to Addition                                                                                       | Worked Example                                                                                                                                       |
| ----------------------------- | ----------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| &nbsp&nbsp&nbsp0111<br>- 1101 | &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp1 (carry in)<br> &nbsp&nbsp&nbsp 0111<br>+ 0010 (bits flipped) | &nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp1 (carry in)<br>&nbsp&nbsp&nbsp 0111<br>+ 0010 (bits flipped)<br><br>   Result:   1010<br>Carry out:  0 |

We further explore the implications of carrying out (or not) in the [overflow section](https://diveintosystems.org/book/C4-Binary/overflow.html#_integer_overflow).
我们进一步探讨在[4.5 数字溢出](4.5%20数字溢出.md)中执行（或不执行）的含义。

