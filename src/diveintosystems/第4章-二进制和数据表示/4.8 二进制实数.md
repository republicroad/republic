While this chapter mainly focuses on binary integer representations, programmers often need to store real numbers, too. Storing real numbers is inherently difficult, and no binary encoding represents real values with perfect precision. That is, for any binary encoding of real numbers, there exist values that cannot be represented _exactly_. Irrational values like _pi_ clearly can’t be represented precisely, since their representation never terminates. Given a fixed number of bits, binary encodings still can’t represent some rational values within their range.

虽然本章主要关注二进制整数表示，但程序员通常也需要存储实数。存储实数本质上是困难的，并且没有任何二进制编码能够以完美的精度表示实值。也就是说，对于实数的任何二进制编码，都存在无法 _精确_ 表示的值。像 _pi_ 这样的无理值显然无法精确表示，因为它们的表示永远不会终止。给定固定的位数，二进制编码仍然无法表示其范围内的一些有理值。

Unlike integers, which are [countably infinite](https://en.wikipedia.org/wiki/Countable_set), the set of real numbers is [uncountable](https://en.wikipedia.org/wiki/Uncountable_set). In other words, even for a narrow range of real values (e.g., between zero and one), the set of values within that range is so large that we can’t even begin to enumerate them. Thus, real number encodings typically store only approximations of values that have been truncated to a predetermined number of bits. Given enough bits, the approximations are typically precise enough for most purposes, but be careful when writing applications that cannot tolerate rounding.

与[可数无限](https://en.wikipedia.org/wiki/Countable_set)的整数不同，实数集是[不可数](https://en.wikipedia.org/wiki/Uncountable_set)。换句话说，即使对于较小范围的实际值（例如，0 到 1 之间），该范围内的值集合也很大，以至于我们甚至无法开始枚举它们。因此，实数编码通常仅存储已被截断为预定位数的值的近似值。如果有足够的位，近似值对于大多数用途来说通常足够精确，但在编写不能容忍舍入的应用程序时要小心。

The remainder of this section briefly describes two methods for representing real numbers in binary: _fixed-point_, which extends the binary integer format, and _floating-point_, which represents a large range of values at the cost of some extra complexity.

本节的其余部分简要介绍了两种用二进制表示实数的方法：_定点_，它扩展了二进制整数格式，以及 _浮点_，它以一些额外的复杂性为代价表示大范围的值。

### 4.8.1. 定点数(Fixed-Point)表示

In a **fixed-point representation**, the position of a value’s _binary point_ remains fixed and cannot be changed. Like a _decimal point_ in a decimal number, the binary point indicates where the fractional portion of the number begins. The fixed-point encoding rules resemble the [unsigned integer](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers) representation, with one major exception: the digits after the binary point represent powers of two raised to a _negative_ value. For example, consider the eight-bit sequence 0b000101.10 in which the first six bits represent whole numbers, and the remaining two bits represent the fractional part. [Figure 1](https://diveintosystems.org/book/C4-Binary/floating_point.html#FigFixed) labels the digit positions and their individual interpretations.

在**定点表示**中，值的 _二进制点_ 的位置保持固定且无法更改。就像十进制数中的小数点一样，二进制小数点表示数字的小数部分开始的位置。定点编码规则类似于[无符号整数](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers)表示形式，但有一个主要例外：二进制小数点后面的数字表示 2 的负数幂。例如，考虑八位序列 0b000101.10，其中前六位代表整数，其余两位代表小数部分。 [图 1](https://diveintosystems.org/book/C4-Binary/floating_point.html#FigFixed) 标记了数字位置及其各自的解释。
![From high-order to low-order, the digits are labeled d5, d4, d3, d2, d1, d0, d-1, d-2.  d-1 contributes 0.5, and d-2 contributes 0.25 to the value.](https://diveintosystems.org/book/C4-Binary/_images/Fixed.png)

Figure 1. The value of each digit in an eight-bit number with two bits after the fixed binary point
图 1. 固定二进制小数点后两位的八位数字中每位数字的值

Applying the formula for converting 0b000101.10 to decimal shows:
应用将 0b000101.10 转换为十进制的公式显示：

(0 × 2<sup>5</sup>) + (0 × 2<sup>4</sup>) + (0 × 2<sup>3</sup>)  +  (1 × 2<sup>2</sup>)  + (0 × 2<sup>1</sup>)  +  (1 × 2<sup>0</sup>) +  (1 × 2<sup>-1</sup>)  +  (0 × 2<sup>-2</sup>)  
  =    0 + 0 + 0 + 4 + 0 + 1 + 0.5 + 0    =    5.5

More generally, with two bits after the binary point, the fractional portion of a number holds one of four sequences: 00 (.00), 01 (.25), 10 (.50), or 11 (.75). Thus, two fractional bits allow a fixed-point number to represent fractional values that are precise to 0.25 (2<sup>-2</sup>). Adding a third bit increases the precision to 0.125 (2<sup>-3</sup>), and the pattern continues similarly, with _N_ bits after the binary point enabling 2<sup>-N</sup>precision.
更一般地，在二进制小数点后的两位中，数字的小数部分保存四个序列之一：00 (.00)、01 (.25)、10 (.50) 或 11 (.75)。因此，两个小数位允许定点数表示精确到 0.25 (2<sup>-2</sup>) 的小数值。添加第三位可将精度提高到 0.125 (2<sup>-3</sup>)，并且该模式类似地继续，二进制小数点后的 _N_ 位可实现 2<sup>-N</sup>精度。

Because the number of bits after the binary point remains fixed, some computations with fully precise operands may produce a result that requires truncation (rounding). Consider the same eight-bit fixed-point encoding from the previous example. It precisely represents both 0.75 (0b000000.11) and 2 (0b000010.00). However, it cannot precisely represent the result of dividing 0.75 by 2: the computation _should_ produce 0.375, but storing it would require a third bit after the binary point (0b000000.01**1**). Truncating the rightmost 1 enables the result to fit within the specified format, but it yields a rounded result of 0.75 / 2 = 0.25. In this example, the rounding is egregious due to the small number of bits involved, but even longer bit sequences will require truncation at some point.
由于二进制小数点之后的位数保持固定，因此某些具有完全精确操作数的计算可能会产生需要截断（舍入）的结果。考虑与上一个示例相同的八位定点编码。它精确地表示 0.75 (0b000000.11) 和 2 (0b000010.00)。然而，它不能精确地表示 0.75 除以 2 的结果：计算应该产生 0.375，但存储它需要二进制小数点后的第三位 (0b000000.01**1**)。截断最右边的 1 可使结果符合指定的格式，但会产生 0.75 / 2 = 0.25 的舍入结果。在此示例中，由于涉及的位数较少，舍入非常严重，但即使更长的位序列在某些点也需要截断。


Even worse, rounding errors compound over the course of intermediate calculations, and in some cases the result of a sequence of computations might vary according to the order in which they’re performed. For example, consider two arithmetic sequences under the same eight-bit fixed-point encoding described earlier:
更糟糕的是，舍入误差在中间计算过程中会复合，并且在某些情况下，一系列计算的结果可能会根据计算的执行顺序而变化。例如，考虑前面描述的相同八位定点编码下的两个算术序列：

1. `(0.75 / 2) * 3    =    0.75`
2. `(0.75 * 3) / 2    =    1.00`


Note that the only difference between the two is the order of the multiplication and division operations. If no rounding were necessary, both computations should produce the same result (1.125). However, due to truncation occurring at different locations in the arithmetic, they produce different results:

1. Proceeding from left to right, the intermediate result (`0.75 / 2`) gets rounded to 0.25 and ultimately produces 0.75 when multiplied by 3.
    
2. Proceeding from left to right, the intermediate computation (`0.75 * 3`) precisely yields 2.25 without any rounding. Dividing 2.25 by 2 rounds to a final result of 1.
    

请注意，两者之间的唯一区别是乘法和除法运算的顺序。如果不需要舍入，则两次计算应产生相同的结果 (1.125)。然而，由于截断发生在算术中的不同位置，它们产生不同的结果：

1. 从左到右，中间结果 (`0.75 / 2`) 四舍五入为 0.25，最终乘以 3 得到 0.75。
2. 从左到右，中间计算 (`0.75 * 3`) 精确地产生 2.25，无需任何舍入。将 2.25 除以 2 轮，最终结果为 1。

In this example, just one additional bit for the 2-3 place allows the example to succeed with full precision, but the fixed-point position we chose only allowed for two bits after the binary point. All the while, the high-order bits of the operands went entirely unused (digits d2 through d5 were never set to 1). At the cost of extra complexity, an alternative representation (floating-point) allows the full range of bits to contribute to a value regardless of the split between whole and fractional parts.

在此示例中，只需为 2-3 位添加一位即可使该示例以全精度成功，但我们选择的定点位置仅允许二进制小数点后的两位。一直以来，操作数的高位都完全未使用（数字 d2 到 d5 从未设置为 1）。以额外的复杂性为代价，另一种表示形式（浮点）允许整个位范围对一个值做出贡献，而不管整数部分和小数部分之间的划分如何。

### 4.8.2. 浮点数(Floating-Point)表示

In a **floating-point representation**, a value’s binary point is _not_ fixed into a predefined position. That is, the interpretation of a binary sequence must encode how it’s representing the split between the whole and fractional parts of a value. While the position of the binary point could be encoded in many possible ways, this section focuses on just one, the [Institute of Electrical and Electronics Engineers (IEEE) standard 754](https://en.wikipedia.org/wiki/IEEE_754). Almost all modern hardware follows the IEEE 754 standard to represent floating-point values.
在**浮点数表示**中，值的二进制小数点 _不_ 固定在预定义的位置。也就是说，二进制序列的解释必须对其如何表示值的整数部分和小数部分之间的分割进行编码。虽然二进制小数点的位置可以通过多种可能的方式进行编码，但本节仅关注其中一种，即[电气和电子工程师协会 (IEEE) 标准 754](https://en.wikipedia.org/wiki/IEEE_754)。几乎所有现代硬件都遵循 IEEE 754 标准来表示浮点值。

![The leftmost digit represents the sign bit.  The next eight bits represent the exponent, and the remaining 23 bits represent the significand.](https://diveintosystems.org/book/C4-Binary/_images/IEEE754.png)

Figure 2. The 32-bit IEEE 754 floating-point standard
图 2. 32 位 IEEE 754 浮点标准

[Figure 2](https://diveintosystems.org/book/C4-Binary/floating_point.html#FigIEEE754) illustrates the IEEE 754 interpretation of a 32-bit floating-point number (C’s `float` type). The standard partitions the bits into three regions:

1. The low-order 23 bits (digits d22 through d0) represent the _significand_ (sometimes called the _mantissa_). As the largest region of bits, the significand serves as the foundation for the value, which ultimately gets altered by multiplying it according to the other bit regions. When interpreting the significand, its value implicitly follows a 1 and binary point. The fractional portion behaves like the fixed-point representation described in the previous section.
    
    For example, if the bits of the significand contain 0b110000…​0000, the first bit represents 0.5 (1 × 2<sup>-1</sup>), the second bit represents 0.25 (1 × 2<sup>-2</sup>), and all the remaining bits are zeros, so they don’t affect the value. Thus, the significand contributes 1.(0.5 + 0.25), or 1.75.
    
2. The next eight bits (digits d30 through d23) represent the _exponent_, which scales the significand’s value to provide a wide representable range. The significand gets multiplied by 2exponent - 127, where the 127 is a _bias_ that enables the float to represent both very large and very small values.
    
3. The final high-order bit (digit d31) represents the _sign bit_, which encodes whether the value is positive (0) or negative (1).
    
[图 2](https://diveintosystems.org/book/C4-Binary/floating_point.html#FigIEEE754) 说明了 32 位浮点数（C 的“float”类型）的 IEEE 754 解释。该标准将位划分为三个区域：

1. 低 23 位（数字 d22 到 d0）表示 _有效数_（有时称为 _尾数_）。作为最大的位区域，有效数充当值的基础，最终通过与其他位区域相乘来改变值。解释有效数时，其值隐式跟随 1 和二进制小数点。小数部分的行为类似于上一节中描述的定点表示。

	例如，如果尾数位包含 0b110000…​0000，则第一位代表 0.5 (1 × 2<sup>-1</sup>)，第二位代表 0.25 (1 × 2<sup>-2</sup>)，其余位全部为零，因此不会影响该值。因此，有效数贡献 1.(0.5 + 0.25) 或 1.75。

2. 接下来的八位（数字 d30 到 d23）表示 _指数_(_exponent_) ，它缩放尾数的值以提供较宽的可表示范围。尾数乘以 2<sup>exponent-127</sup>，其中 127 是一个 _偏差_(_bias_) ，使浮点数能够表示非常大和非常小的值。

3. 最后的高位（数字 d31）代表 _符号位_，它对值是正 (0) 还是负 (1) 进行编码。


As an example, consider decoding the bit sequence 0b11000001101101000000000000000000. The significand portion is 01101000000000000000000, which represents 2-2 + 2-3 + 2-5 = 0.40625, so the signifcand region contributes 1.40625. The exponent is 10000011, which represents the decimal value 131, so the exponent contributes a factor of 2(131-127) (16). Finally, the sign bit is 1, so the sequence represents a negative value. Putting it all together, the bit sequence represents:

例如，考虑解码比特序列 0b11000001101101000000000000000000。有效数字部分为 01101000000000000000000，表示  2<sup>-2</sup>+  2<sup>-3</sup> +  2<sup>-5</sup> = 0.40625，因此有效数字区域贡献 1.40625。指数为 10000011，代表十进制值 131，因此指数贡献的因子为 2<sup>(131-127)</sup>(16)。最后，符号位为1，因此该序列代表负值。将它们放在一起，位序列表示：

1.40625 × 16 × -1  = -22.5

While clearly more complex than the fixed-point scheme described earlier, the IEEE floating-point standard provides additional flexibility for representing a wide range of values. Despite the flexibility, a floating-point format with a constant number of bits still can’t precisely represent every possible value. That is, like fixed-point, rounding problems similarly affect floating-point encodings.

虽然 IEEE 浮点标准显然比前面描述的定点方案更复杂，但它为表示各种值提供了额外的灵活性。尽管具有灵活性，但具有恒定位数的浮点格式仍然无法精确表示每个可能的值。也就是说，与定点一样，舍入问题同样会影响浮点编码。

### 4.8.3. 四舍五入的影响

While rounding isn’t likely to ruin most of the programs you write, real number rounding errors have occasionally caused some high-profile system failures. During the Gulf War in 1991, a rounding error caused an American Patriot missile battery to [fail to intercept an Iraqi missile](http://www-users.math.umn.edu/~arnold/disasters/patriot.html). The missile killed 28 soldiers and left many others wounded. In 1996, the European Space Agency’s first launch of the Ariane 5 rocket [exploded 39 seconds after taking off](https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284). The rocket, which borrowed much of its code from the Ariane 4, triggered an overflow when attempting to convert a floating-point value into an integer value.

虽然舍入不太可能破坏您编写的大多数程序，但实数舍入错误偶尔会导致一些引人注目的系统故障。 1991 年海湾战争期间，舍入错误导致美国爱国者导弹电池[未能拦截伊拉克导弹](http://www-users.math.umn.edu/~arnold/disasters/patriot.html)。导弹造成 28 名士兵死亡，多人受伤。 1996 年，欧洲航天局首次发射阿丽亚娜 5 号火箭[起飞后 39 秒爆炸](https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284)。该火箭借用了阿丽亚娜 4 号的大部分代码，在尝试将浮点值转换为整数值时触发了溢出。