
You’re likely to encounter each of the three number bases we’ve introduced in this chapter in different contexts. In some cases, you may need to convert from one base to another. This section starts by showing how to convert between binary and hexadecimal, since those two map easily to each other. After that, we’ll explore conversions to and from decimal.
您可能会在不同的环境中遇到本章中介绍的三种进制数基。在某些情况下，您可能需要从一种基础转换为另一种基础。本节首先展示如何在二进制和十六进制之间进行转换，因为这两者很容易相互映射。之后，我们将探讨十进制之间的转换。

### 4.2.1. 二进制和十六进制之间的转换

Because the bases for both binary and hexadecimal are powers of 2, converting between the two is relatively straightforward. Specifically, each hexadecimal digit holds one of 16 unique values, and four bits also represents 24 = 16 unique values, making their expressive power equivalent. [Table 1](https://diveintosystems.org/book/C4-Binary/conversion.html#TabHexBinary) enumerates the one-to-one mapping between any sequence of four bits and any single hexadecimal digit.

由于二进制和十六进制的基数都是 2 的幂，因此两者之间的转换相对简单。具体来说，每个十六进制数字保存 16 个唯一值之一，四位也代表 24 = 16 个唯一值，使得它们的表达能力相当。 [表 1](https://diveintosystems.org/book/C4-Binary/conversion.html#TabHexBinary) 枚举了任何四位序列与任何单个十六进制数字之间的一对一映射。

Table 1. The Correspondence Between All Four-Bit Sequences and One-Digit Hexadecimal Numbers
表 1. 所有四位序列与一位十六进制数之间的对应关系

| Binary | Hexadecimal | Binary | Hexadecimal |
| ------ | ----------- | ------ | ----------- |
| 0000   | 0           | 1000   | 8           |
| 0001   | 1           | 1001   | 9           |
| 0010   | 2           | 1010   | A           |
| 0011   | 3           | 1011   | B           |
| 0100   | 4           | 1100   | C           |
| 0101   | 5           | 1101   | D           |
| 0110   | 6           | 1110   | E           |
| 0111   | 7           | 1111   | F           |

Note that the content of [Table 1](https://diveintosystems.org/book/C4-Binary/conversion.html#TabHexBinary) is equivalent to simply counting from 0 to 15 in both number systems, so there’s no need to memorize it. Armed with this mapping, you can convert any number of consecutive bits or hex digits in either direction:

- Converting 0xB491 to binary, simply substitute the corresponding binary value for each hexadecimal digit:
    
```bash
      B    4    9    1
    1011 0100 1001 0001  ->  0b1011010010010001
```
    
- Converting 0b1111011001 to hexadecimal, first divide up the bits into chunks of four, from _right to left_. If the leftmost chunk doesn’t have four bits, you can pad with leading zeros. Then, substitute the corresponding hexadecimal values:
    
```bash
    1111011001  ->  11 1101 1001  ->  0011 1101 1001
                                      ^ padding
    
    0011 1101 1001
      3    D    9  ->  0x3D9
```

请注意，[表 1](https://diveintosystems.org/book/C4-Binary/conversion.html#TabHexBinary) 的内容相当于简单地在两种数字系统中从 0 数到 15，因此无需记住它。有了这个映射，您可以在任一方向上转换任意数量的连续位或十六进制数字：
- 将 0xB491 转换为二进制，只需将每个十六进制数字替换为相应的二进制值即可：

```bash
  B    4    9    1
1011 0100 1001 0001  ->  0b1011010010010001
```

- 将 0b1111011001 转换为十六进制，首先将这些位从右到左分成四个块。如果最左边的块没有四位，则可以用前导零填充。然后，替换相应的十六进制值：

```bash
1111011001  ->  11 1101 1001  ->  0011 1101 1001
								  ^ padding

0011 1101 1001
  3    D    9  ->  0x3D9
````
### 4.2.2. 转换为十进制

Fortunately, converting values to decimal is what we’ve been doing throughout [previous sections of this chapter](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers). Given a number in _any_ base **B**, labeling the digits from _right to left_ as d0, d1, d2, etc. enables a general formula for converting values to decimal:

幸运的是，将值转换为十进制是我们在[本章前面的部分](https://diveintosystems.org/book/C4-Binary/bases.html#_unsigned_binary_numbers)中一直在做的事情。给定一个以_any_为基数**B**的数字，将从右到左的数字标记为d0、d1、d2等，可以使用将值转换为十进制的通用公式：

(d<sub>N-1</sub> × **B**<sup>N-1</sup>)    +    (d<sub>N-2</sub> × **B**<sup>N-2</sup>)    +    …​    +    (d<sub>2</sub> × **B**<sup>2</sup>)    +    (d<sub>1</sub> × **B**<sup>1</sup>)    +    (d<sub>0</sub> × **B**<sup>0</sup>)
### 4.2.3. 从十进制转换

Converting from decimal to other systems requires a little more work. Informally, the goal is to do the reverse of the previous formula: determine the value of each digit such that, based on the position of the digit, adding each term results in the source decimal number. It may help to think about each digit in the target base system in the same way that we described the places (the "ones" place, the "tens" place, etc.) for decimal. For example, consider converting from decimal to hexadecimal. Each digit of a hexadecimal number corresponds to an increasingly large power of 16, and [Table 2](https://diveintosystems.org/book/C4-Binary/conversion.html#TabPowersSixteen) lists the first few powers.

从十进制转换为其他系统需要更多的工作。非正式地，目标是执行与上一个公式相反的操作：确定每个数字的值，以便根据数字的位置，将每一项相加得到源十进制数。以与我们描述小数位（“个”位、“十”位等）相同的方式来思考目标基本系统中的每个数字可能会有所帮助。例如，考虑从十进制转换为十六进制。十六进制数的每一位都对应于 16 的越来越大的幂，[表 2](https://diveintosystems.org/book/C4-Binary/conversion.html#TabPowersSixteen) 列出了前几个幂。

Table 2. Powers of 16.
表 2. 16 的幂。

| 16<sup>4</sup> | 16<sup>3</sup> | 16<sup>2</sup> | 16<sup>1</sup> | 16<sup>0</sup> |
| -------------- | -------------- | -------------- | -------------- | -------------- |
| 65536          | 4096           | 256            | 16             | 1              |

For example, to convert **9742** to hexadecimal, consider:
例如，要将 **9742** 转换为十六进制，请考虑：

- _How many multiples of 65536 fit into 9742? (In other words, what is the value of the "65536’s" place?)_
- _9742 可以容纳 65536 的多少倍数？ （也就是说，“65536”这个地方的值是多少？）_
    
    The resulting hexadecimal value doesn’t need any multiples of 65536, since the value (9742) is smaller than 65536, so d4 should be set to 0. Note that by the same logic, all higher-numbered digits will also be 0, because each digit would contribute values even larger than 65536. Thus far, the result contains only:
    生成的十六进制值不需要任何 65536 的倍数，因为值 (9742) 小于 65536，因此 d4 应设置为 0。请注意，通过相同的逻辑，所有更高编号的数字也将为 0，因为每个数字将贡献比 65536 更大的值。到目前为止，结果仅包含：

| 0              |                |                |                |                |
| -------------- | -------------- | -------------- | -------------- | -------------- |
| 16<sup>4</sup> | 16<sup>3</sup> | 16<sup>2</sup> | 16<sup>1</sup> | 16<sup>0</sup> |
| 65536          | 4096           | 256            | 16             | 1              |
| d4             | d3             | d2             | d1             | d0             |

    
- _How many multiples of 4096 fit into 9742? (In other words, what is the value of the "4096’s" place?)_
- _9742 能容纳多少 4096 的倍数？ （也就是说，“4096”这个地方的价值是多少？）
    
    4096 fits into 9742 twice (2 × 4096 = 8192), so the value of d3 should be 2. Thus, d3 will contribute 8192 to the overall value, so the result must still account for 9742 - 8192 = 1550.
    4096 适合 9742 两次 (2 × 4096 = 8192)，因此 d3 的值应为 2。因此，d3 将为整体值贡献 8192，因此结果仍必须占 9742 - 8192 = 1550。

| 0              | 2              |                |                |                |
| -------------- | -------------- | -------------- | -------------- | -------------- |
| 16<sup>4</sup> | 16<sup>3</sup> | 16<sup>2</sup> | 16<sup>1</sup> | 16<sup>0</sup> |
| 65536          | 4096           | 256            | 16             | 1              |
| d4             | d3             | d2             | d1             | d0             |

- _How many multiples of 256 fit into 1550? (In other words, what is the value of the "256’s" place?)_
- _1550 能容纳多少 256 的倍数？ （也就是说，“256”位的值是多少？）_
    
    256 fits into 1550 six times (6 × 256 = 1536), so the value of d2 should be 6, leaving 1550 - 1536 = 14.
    256 适合 1550 六次 (6 × 256 = 1536)，因此 d2 的值应为 6，剩下 1550 - 1536 = 14。

| 0              | 2              | 6              |                |                |
| -------------- | -------------- | -------------- | -------------- | -------------- |
| 16<sup>4</sup> | 16<sup>3</sup> | 16<sup>2</sup> | 16<sup>1</sup> | 16<sup>0</sup> |
| 65536          | 4096           | 256            | 16             | 1              |
| d4             | d3             | d2             | d1             | d0             |

- _How many multiples of 16 fit into 14? (In other words, what is the value of the "sixteens" place?)_
- _14 能容纳多少 16 的倍数？ （也就是说，“十六”位的值是多少？）_
    
    None, so d1 must be 0.
    14不能被16整除，因此 d1 必须为 0。

| 0              | 2              | 6              | 0              |                |
| -------------- | -------------- | -------------- | -------------- | -------------- |
| 16<sup>4</sup> | 16<sup>3</sup> | 16<sup>2</sup> | 16<sup>1</sup> | 16<sup>0</sup> |
| 65536          | 4096           | 256            | 16             | 1              |
| d4             | d3             | d2             | d1             | d0             |

- _Finally, how many multiples of 1 fit into 14? (In other words, what is the value of the "ones" place?)_
- _最后，14 能容纳多少个 1 的倍数？ （换句话说，“个”位的值是多少？）_
    
    The answer is 14, of course, which hexadecimal represents with the digit `E`.
    答案当然是 14，十六进制用数字“E”表示。

| 0              | 2              | 6              | 0              | E              |
| -------------- | -------------- | -------------- | -------------- | -------------- |
| 16<sup>4</sup> | 16<sup>3</sup> | 16<sup>2</sup> | 16<sup>1</sup> | 16<sup>0</sup> |
| 65536          | 4096           | 256            | 16             | 1              |
| d4             | d3             | d2             | d1             | d0             |

Thus, decimal 9742 corresponds to 0x260E.
因此，十进制 9742 对应于 0x260E。

#### 十进制转二进制：二的幂

The same procedure works for binary, as well (or any other number system), provided that you use powers of the appropriate base. [Table 3](https://diveintosystems.org/book/C4-Binary/conversion.html#TabPowersTwo) lists the first few powers of two, which will help to convert the example decimal value **422** to binary.
相同的过程也适用于二进制（或任何其他数字系统），前提是您使用适当基数的幂。 [表 3](https://diveintosystems.org/book/C4-Binary/conversion.html#TabPowersTwo) 列出了 2 的前几个幂，这将有助于将示例十进制值 **422** 转换为二进制。

Table 3. Powers of Two
表 3. 2 的幂

| 2<sup>8</sup> | 2<sup>7</sup> | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> |
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- |
| 256           | 128           | 64            | 32            | 16            | 8             | 4             | 2             | 1             |

Because an individual bit is only allowed to store a 0 or 1, the question is no longer _"How many multiples of each power fit within a value?"_ when converting to binary. Instead, ask a simpler question: _"Does the next power of two fit?"_ For example, in converting 422:

- 256 fits into 422, so d8 should be a 1. That leaves 422 - 256 = 166.
- 128 fits into 166, so d7 should be a 1. That leaves 166 - 128 = 38.
- 64 does not fit into 38, so d6 should be a 0.
- 32 fits into 38, so d5 should be a 1. That leaves 38 - 32 = 6.
- 16 does not fit into 6, so d4 should be a 0.
- 8 does not fit into 6, so d3 should be a 0.
- 4 fits into 6, so d2 should be a 1. That leaves 6 - 4 = 2.
- 2 fits into 2, so d1 should be a 1. That leaves 2 - 2 = 0. (Note: upon reaching 0, all remaining digits will always be 0.)
- 1 does not fit into 0, so d0 should be a 0.

因为单个位只允许存储 0 或 1，所以转换为二进制时，问题不再是 _“每个幂的多少倍适合一个值？”_。相反，问一个更简单的问题：_“2 的下一个幂适合吗？”_ 例如，在转换 422 时：

- 256 整除 422，因此 d8 应为 1。剩下 422 - 256 = 166。
- 128 整除 166，所以 d7 应该是 1。剩下 166 - 128 = 38。
- 64 无法整除 38，因此 d6 应为 0。
- 32 整除 38，所以 d5 应该是 1。剩下 38 - 32 = 6。
- 16 无法整除 6，因此 d4 应为 0。
- 8 无法整除 6，因此 d3 应为 0。
- 4 整除 6，所以 d2 应该是 1。剩下 6 - 4 = 2。
- 2 适合 2，因此 d1 应为 1。这样就剩下 2 - 2 = 0。（注意：达到 0 后，所有剩余数字将始终为 0。）
- 1 无法整除 0，因此 d0 应为 0。

Thus, decimal 422 corresponds to 0b110100110.
因此，十进制 422 对应于 0b110100110。
#### 十进制转二进制：重复除法(辗转相除法)

The method we just described generally works well for students who are familiar with the relevant powers of two (e.g., for 422, the converter must recognize that it should start at d8 because 2<sup>9</sup> = 512 is too large).
我们刚刚描述的方法通常对于熟悉 2 的相关幂的学生来说效果很好（例如，对于 422，转换器必须认识到它应该从 d8 开始，因为  2<sup>9</sup> = 512 太大）。

An alternative method doesn’t require knowing powers of two. Instead, this method builds a binary result by checking the parity (even or odd) status of a decimal number and repeatedly dividing it by two (rounding halves down) to determine each successive bit. Note that it builds the resulting bit sequence from _right to left_. If the decimal value is even, the next bit should be a zero; if it’s odd, the next bit should be a one. When the division reaches zero, the conversion is complete.
另一种方法不需要知道二的幂。相反，此方法通过检查十进制数的奇偶校验（偶数或奇数）状态并重复将其除以二（向下四舍五入）以确定每个连续位来构建二进制结果。请注意，它从_右到左_构建结果位序列。如果十进制值为偶数，则下一位应为零；如果是奇数，下一位应该是 1。当除法达到零时，转换完成。

For example, when converting 422:

- 422 is even, so d0 should be a 0. (This is the rightmost bit.)
    
- 422 / 2 = 211, which is odd, so d1 should be a 1.
    
- 211 / 2 = 105, which is odd, so d2 should be a 1.
    
- 105 / 2 = 52, which is even, so d3 should be a 0.
    
- 52 / 2 = 26, which is even, so d4 should be a 0.
    
- 26 / 2 = 13, which is odd, so d5 should be a 1.
    
- 13 / 2 = 6, which is even, so d6 should be a 0.
    
- 6 / 2 = 3, which is odd, so d7 should be a 1.
    
- 3 / 2 = 1, which is odd, so d8 should be a 1.
    
- 1 / 2 = 0, so any digit numbered nine or above will be 0, and the algorithm terminates.

例如，转换 422 时：
- 422 是偶数，因此 d0 应为 0。（这是最右边的位。）
- 422 / 2 = 211，这是奇数，因此 d1 应为 1。
- 211 / 2 = 105，这是奇数，因此 d2 应为 1。
- 105 / 2 = 52，是偶数，因此 d3 应为 0。
- 52 / 2 = 26，是偶数，因此 d4 应为 0。
- 26 / 2 = 13，这是奇数，因此 d5 应为 1。
- 13 / 2 = 6，是偶数，因此 d6 应为 0。
- 6 / 2 = 3，这是奇数，因此 d7 应为 1。
- 3 / 2 = 1，这是奇数，因此 d8 应为 1。
- 1 / 2 = 0，因此任何编号为 9 或以上的数字都将为 0，并且算法终止。

As expected, this method produces the same binary sequence: 0b110100110.
正如预期的那样，此方法生成相同的二进制序列：0b110100110。