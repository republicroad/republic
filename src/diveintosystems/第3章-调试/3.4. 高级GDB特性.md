## 3.4. 高级GDB特性

This section presents advanced GDB features, some of which may make sense only after reading the [Operating Systems](https://diveintosystems.org/book/C13-OS/index.html#_the_operating_system) chapter.

本节介绍高级 GDB 功能，其中一些功能只有在阅读了[操作系统](https://diveintosystems.org/book/C13-OS/index.html#_the_operating_system) 章节后才有意义。

### 3.4.1. GDB和make

GDB accepts the `make` command to rebuild an executable during a debugging session, and if the build is successful it will run the newly built program (when issued the `run` command).

GDB 接受 `make` 命令以在调试会话期间重建可执行文件，如果构建成功，它将运行新构建的程序（当发出 `run` 命令时）。

```bash
(gdb) make
(gdb) run
```

Building from within GDB is convenient for a user who has set many breakpoints and has fixed one bug but wants to continue the debugging session. In this case, rather than quitting GDB, recompiling, restarting GDB with the new executable, and resetting all the breakpoints, a GDB user can run `make` and start debugging the new version of the program with all the breakpoints still set. Keep in mind, however, that modifying the C source and recompiling by running `make` from within GDB may result in the breakpoints not being at the same logical location in the new version of the program as in the old version if source code lines have been added or deleted. When this problem occurs, either exit GDB and restart the GDB session on the new executable, or use `disable` or `delete` to disable or delete the old breakpoints and then `break` to set new breakpoints at the correct locations in the newly compiled version of the program.

对于设置了许多断点并修复了一个错误但想要继续调试会话的用户来说，从 GDB 中进行构建非常方便。在这种情况下，GDB 用户可以运行 `make` 并在仍然设置所有断点的情况下开始调试程序的新版本，而不是退出 GDB、重新编译、使用新的可执行文件重新启动 GDB 以及重置所有断点。但请记住，如果添加或删除了源代码行，则通过在 GDB 中运行 `make` 来修改 C 源代码并重新编译可能会导致新版本程序中的断点与旧版本中的断点不在同一逻辑位置。出现此问题时，请退出 GDB 并在新的可执行文件上重新启动 GDB 会话，或者使用 `disable` 或 `delete` 禁用或删除旧断点，然后使用 `break` 在新编译的程序版本中的正确位置设置新断点。

### 3.4.2. 将 GDB 附加到正在运行的进程

GDB supports debugging a program that is already running (rather than starting a program to run from within a GDB session) by _attaching_ GDB to a running process. To do this, the user needs to get the process ID (PID) value:

GDB 支持通过将 GDB 连接到正在运行的进程来调试已在运行的程序（而不是在 GDB 会话中启动程序运行）。为此，用户需要获取进程 ID (PID) 值：

1. Get the process’s PID using the `ps` shell command:使用 `ps` shell 命令获取进程的 PID：

```bash
    # ps to get process's PID (lists all processes started in current shell):
    $ ps
    
    # list all processes and pipe through grep for just those named a.out:
    $ ps -A | grep a.out
       PID TTY          TIME CMD
       12345 pts/3     00:00:00 a.out
    
```

1. Start GDB and attach it to the specific running process (with PID 12345):启动GDB并将其附加到特定的运行进程（PID为12345）：

```bash
    # gdb <executable> <pid>
    $ gdb a.out 12345
    (gdb)
    
    # OR alternative syntax: gdb attach <pid>  <executable>
    $ gdb attach 12345 a.out
    (gdb)
```



Attaching GDB to a process pauses it, and the user can issue GDB commands before continuing its execution.

将 GDB 附加到进程会暂停该进程，用户可以在继续执行之前发出 GDB 命令。

Alternatively, a program can explicitly pause itself to wait for debugging by calling `kill(getpid(), SIGSTOP)` (as in the [attach_example.c](https://diveintosystems.org/book/C3-C_debug/_attachments/attach_example.c) example). When the program pauses at this point, a programmer can attach GDB to the process to debug it.

或者，程序可以通过调用 `kill(getpid(), SIGSTOP)` 显式暂停自身以等待调试（如 [attach_example.c](https://diveintosystems.org/book/C3-C_debug/_attachments/attach_example.c) 示例中所示）。当程序此时暂停时，程序员可以将 GDB 附加到进程中以对其进行调试。

Regardless of how a program pauses, after GDB attaches and the user enters some GDB commands, the program’s execution continues from its attach point using `cont`. If `cont` doesn’t work, GDB may need to explicitly send the process a `SIGCONT` signal in order to continue its execution:

无论程序如何暂停，在 GDB 连接进程并且用户输入一些 GDB 命令后，程序都会使用 `cont` 从其连接点继续执行。如果 `cont` 不起作用，GDB 可能需要显式向进程发送 `SIGCONT` 信号才能继续执行：

```gdb
 (gdb) signal SIGCONT
```

### 3.4.3. 跟踪fork系统调用之后的进程

When GDB debugs a program that calls the `fork()` function to create a new child process, GDB can be set to follow (to debug) either the parent process or the child process, leaving the execution of the other process unaffected by GDB. By default, GDB follows the parent after a call to `fork()`. To set GDB to follow the child process, instead, use the `set follow-fork-mode` command:

当GDB调试一个调用`fork()`函数创建新子进程的程序时，可以将GDB设置为跟随（调试）父进程或子进程，使另一个进程的执行不受GDB影响。默认情况下，GDB 在调用 `fork()` 后跟随父级。要将 GDB 设置为跟随子进程，请使用 `set follow-fork-mode` 命令：

```gdb
(gdb) set follow-fork-mode child    # Set gdb to follow child on fork

(gdb) set follow-fork-mode parent   # Set gdb to follow parent on fork
(gdb) show follow-fork-mode         # Display gdb's follow mode
```

Setting breakpoints at `fork()` calls in the program is useful when the user wants to change this behavior during a GDB session.

当用户想要在 GDB 会话期间更改此行为时，在程序中的 `fork()` 调用处设置断点非常有用。

The [attach_example.c](https://diveintosystems.org/book/C3-C_debug/_attachments/attach_example.c) example shows one way to "follow" both processes on a fork: GDB follows the parent process after the fork, and the child sends itself a `SIGSTOP` signal to explicitly pause after the fork, allowing the programmer to attach a second GDB process to the child before it continues.

[attach_example.c](https://diveintosystems.org/book/C3-C_debug/_attachments/attach_example.c) 示例展示了一种在 fork 上"跟随"两个进程的方法：GDB 在 fork 后跟随父进程，子进程向自己发送一个 `SIGSTOP` 信号以在 fork 后显式暂停，从而允许程序员在继续之前将第二个 GDB 进程附加到子进程。

### 3.4.4. 信号控制

The GDB process can send signals to the target process it is debugging and can handle signals received by the target process.

GDB进程可以向正在调试的目标进程发送信号，并且可以处理目标进程接收到的信号。

GDB can send signals to the process it debugs using the `signal` command:

GDB 可以使用 `signal` 命令向其调试的进程发送信号：

```gdb
(gdb) signal SIGCONT
(gdb) signal SIGALARM
...
```

Sometimes a user would like GDB to perform some action when a signal is received by the debugged process. For example, if a program tries to access memory with a misaligned memory address for the type it is accessing, it receives a `SIGBUS` signal and usually exits. The default behavior of GDB on a `SIGBUS` is also to let the process exit. If, however, you want GDB to examine the program state when it receives a `SIGBUS`, you can specify that GDB handle the `SIGBUS` signal differently using the `handle` command (the `info` command shows additional information about how GDB handles signals received by the process during debugging):

有时，用户希望 GDB 在被调试进程收到信号时执行某些操作。例如，如果程序尝试访问其所访问类型的内存地址未对齐的内存，它会收到 `SIGBUS` 信号，并且通常会退出。 GDB 在 `SIGBUS` 上的默认行为也是让进程退出。但是，如果您希望 GDB 在收到 `SIGBUS` 时检查程序状态，则可以使用 `handle` 命令指定 GDB 以不同的方式处理 `SIGBUS` 信号（ `info` 命令显示有关 GDB 在调试期间如何处理进程接收到的信号的附加信息）：

```
(gdb) handle SIGBUS stop    # if program gets a SIGBUS, gdb gets control

(gdb) info signal           # list info on all signals
(gdb) info SIGALRM          # list info just for the SIGALRM signal
```

### 3.4.5. DDD设置和错误修复

Running DDD creates a `.ddd` directory in your home directory, which it uses to store its settings so that users don’t need to reset all their preferences from scratch on each invocation. Some examples of saved settings include sizes of subwindows, menu display options, and enabling windows to view register values and assembly code.

运行 DDD 会在您的主目录中创建一个 `.ddd` 目录，用于存储其设置，以便用户无需在每次调用时从头开始重置所有首选项。保存设置的一些示例包括子窗口的大小、菜单显示选项以及启用窗口以查看寄存器值和汇编代码。

Sometimes DDD hangs on startup with a "Waiting until GDB ready" message. This often indicates an error in its saved settings files. The easiest way to fix this is remove the `.ddd` directory (you will lose all your saved settings and need to reset them when it starts up again):

有时 DDD 在启动时挂起，并显示“等待 GDB 就绪”消息。这通常表明其保存的设置文件中有错误。解决此问题的最简单方法是删除“.ddd”目录（您将丢失所有保存的设置，并且需要在再次启动时重置它们）：

```bash
$ rm -rf ~/.ddd  # Be careful when entering this command!
$ ddd ./a.out
```