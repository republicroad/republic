In addition to the standard arithmetic operations described earlier, CPUs also support operations that are uncommon outside of binary. These **bitwise operators** directly apply the behavior of [logic gates](https://diveintosystems.org/book/C5-Arch/gates.html#_basic_logic_gates) to bit sequences, making them straightforward to implement efficiently in hardware. Unlike addition and subtraction, which programmers typically use to manipulate a variable’s numerical interpretation, programmers commonly use bitwise operators to modify specific bits in a variable. For example, a program might encode a certain bit position in a variable to hold a true/false meaning, and bitwise operations allow the program to manipulate the variable’s individual bits to change that specific bit.

除了前面描述的标准算术运算之外，CPU 还支持二进制之外不常见的运算。这些**按位运算符**直接将 [5.3 逻辑门](../第5章-冯·诺依曼设计：计算机体系结构/5.3%20Logic%20Gates.md) 的行为应用于比特位序列，使它们能够在硬件中直接有效地实现。与程序员通常使用加法和减法来操作变量的数值解释不同，程序员通常使用按位运算符来修改变量中的特定位。例如，程序可能会对变量中的某个位位置进行编码以保存真/假含义，并且按位运算允许程序操纵变量的各个位来更改该特定位。

### 4.6.1. 按位与(Bitwise AND)

The bitwise AND operator (`&`) evaluates two input bit sequences. For each digit of the inputs, it outputs a 1 in the corresponding position of the output if _both_ inputs are 1 in that position. Otherwise, it outputs a 0 for the digit. [Table 1](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabANDTruth) shows the truth table for the bitwise AND of two values, _A_ and _B_.

按位与运算符 (`&`) 计算两个输入位序列。对于输入的每个数字，如果两个输入在该位置均为 1，则它会在输出的相应位置输出 1。否则，它会输出该数字 0。 [表 1](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabANDTruth) 显示了两个值 _A_ 和 _B_ 的按位 AND 的真值表。

Table 1. The Results of Bitwise ANDing Two Values (_A_ AND _B_)
表 1. 按位与两个值的结果 (_A_ AND _B_)

|  A  |  B  | A & B |
| :-: | :-: | :---: |
|  0  |  0  |   0   |
|  0  |  1  |   0   |
|  1  |  0  |   0   |
|  1  |  1  |   1   |

For example, to bitwise AND 0b011010 with 0b110110, start by lining up the two sequences. Checking vertically through each digit, set the result of the column to 1 if _both_ digits are 1. Otherwise, set the result of the column to 0:

例如，要按位与 0b011010 与 0b110110，首先将两个序列对齐。垂直检查每个数字，如果两个数字均为 1，则将该列的结果设置为 1。否则，将该列的结果设置为 0：

```bash
        011010
    AND 110110  Only digits 1 and 4 are 1's in BOTH inputs, so
Result: 010010  those are the only digits set to 1 in the output.
```

To perform a bitwise AND in C, place C’s bitwise AND operator (`&`) between two operand variables. Here’s the same example again, performed in C:

要在 C 中执行按位 AND，请将 C 的按位 AND 运算符 (`&`) 放在两个操作数变量之间。这是用 C 语言执行的相同示例：

```c
int x = 26;
int y = 54;

printf("Result: %d\n", x & y);  // Prints 18
```



> [!NOTE] Bitwise Operations versus Logical Truth Operations
> Be careful not to conflate bitwise operators with [logical truth operators](https://diveintosystems.org/book/C1-C_intro/conditionals.html#_boolean_values_in_c). Despite having similar names (AND, OR, NOT, etc.), the two _are not_ the same:
> 
>  -  Bitwise operators consider each bit of their inputs independently and produce an output bit sequence as a function of the specific input bits that are set.
>   - Logical operators consider only the _truth_ interpretation of their operands. To C, a value of zero is _false_, whereas all other values are considered _true_. Logical operators are often used when evaluating conditionals (e.g., `if` statements).
>
>  Note that C often uses similar (but slightly different) operators to distinguish between the two. For example, you can indicate bitwise AND and bitwise OR using a single `&` and `|`, respectively. Logical AND and logical OR correspond to a double `&&` and `|`. Finally, bitwise NOT uses `~`, whereas logical NOT is expressed by `!`.


> [!NOTE] 按位运算与逻辑真值运算
> 
> 请注意不要将按位运算符与[逻辑真值运算符](https://diveintosystems.org/book/C1-C_intro/conditionals.html#_boolean_values_in_c)混为一谈。尽管名称相似（AND、OR、NOT 等），但这两个_并不_相同：
> 
>  -  按位运算符独立地考虑其输入的每一位，并根据所设置的特定输入位生成输出位序列。
>  -  逻辑运算符仅考虑其操作数的 _truth_ 解释。对于 C，零值是 _false_ ，而所有其他值都被视为 _true_。评估条件（例如`if`语句）时经常使用逻辑运算符。
>
>  请注意，C 经常使用类似（但略有不同）的运算符来区分两者。例如，您可以分别使用单个 `&` 和 `|`来表示按位 AND 和按位 OR。逻辑 AND 和逻辑 OR 对应于双`&&` 和 `|`。最后，按位 NOT 使用`~`，而逻辑 NOT 使用`!`表示。
>  
>  位    运算:  与  &,    或   |,  非  ~
>  逻辑运算:  与  &&, 或   |,  非   !  


### 4.6.2. 按位或(Bitwise OR)

The bitwise OR operator (`|`) behaves like the bitwise AND operator except that it outputs a 1 for a digit if _either or both_ of the inputs is 1 in the corresponding position. Otherwise, it outputs a 0 for the digit. [Table 2](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabORTruth) shows the truth table for the bitwise OR of two values, _A_ and _B_.
按位 OR 运算符 (`|`) 的行为类似于按位 AND 运算符，不同之处在于，如果相应位置的输入中的一个或两个都为 1，则它会为数字输出 1。否则，它会输出该数字 0。 [表 2](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabORTruth) 显示两个值 _A_ 和 _B_ 按位或的真值表。

Table 2. The Results of Bitwise ORing Two Values (_A_ OR _B_)
表 2. 按位或运算两个值的结果 (_A_ OR _B_)

|  A  |  B  | A \| B |
| :-: | :-: | :----: |
|  0  |  0  |   0    |
|  0  |  1  |   1    |
|  1  |  0  |   1    |
|  1  |  1  |   1    |

For example, to bitwise OR 0b011010 with 0b110110, start by lining up the two sequences. Checking vertically through each digit, set the result of the column to 1 if _either_ digit is 1:
例如，要按位或 0b011010 与 0b110110，首先将两个序列对齐。垂直检查每个数字，如果任一数字为 1，则将该列的结果设置为 1：

```bash
        011010
     OR 110110     Only digit 0 contains a 0 in both inputs, so it's
Result: 111110     the only digit not set to 1 in the result.
```

To perform a bitwise OR in C, place C’s bitwise OR operator (`|`) between two operands. Here’s the same example again, performed in C:
要在 C 中执行按位或，请将 C 的按位或运算符 (`|`) 放在两个操作数之间。这是用 C 语言执行的相同示例：

```c
int x = 26;
int y = 54;

printf("Result: %d\n", x | y);  // Prints 62
```

### 4.6.3. 按位异或(XOR, Exclusive OR)

The bitwise XOR operator (`^`) behaves like the bitwise OR operator except that it outputs a 1 for a digit only if _exactly one_ (but not both) of the inputs is 1 in the corresponding position. Otherwise, it outputs a 0 for the digit. [Table 3](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabXORTruth) shows the truth table for the bitwise XOR of two values, _A_ and _B_.
按位 XOR 运算符 (`^`) 的行为类似于按位 OR 运算符，不同之处在于，仅当输入中的_恰好一个_（但不是两个）在相应位置为 1 时，它才会为数字输出 1。否则，它会输出该数字 0。 [表 3](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabXORTruth) 显示了两个值 _A_ 和 _B_ 的按位异或的真值表。

Table 3. The Results of Bitwise XORing Two Values (_A_ XOR _B_)
表 3. 按位异或两个值的结果 (_A_ XOR _B_)

|  A  |  B  | A ^ B |
| :-: | :-: | :---: |
|  0  |  0  |   0   |
|  0  |  1  |   1   |
|  1  |  0  |   1   |
|  1  |  1  |   0   |

For example, to bitwise XOR 0b011010 with 0b110110, start by lining up the two sequences. Checking vertically through each digit, set the result of the column to 1 if _only one_ digit is 1:
例如，要按位异或 0b011010 与 0b110110，首先将两个序列对齐。垂直检查每个数字，如果 _只有一个_ 数字为 1，则将该列的结果设置为 1：

```bash
        011010
    XOR 110110     Digits 2, 3, and 6 contain a 1 in exactly one of
Result: 101100     the two inputs.
```

To perform a bitwise XOR in C, place C’s bitwise XOR operator (`^`) between two operands. Here’s the same example again, performed in C:
要在 C 中执行按位异或，请将 C 的按位异或运算符 (`^`) 放在两个操作数之间。这是用 C 语言执行的相同示例：

```c
int x = 26;
int y = 54;

printf("Result: %d\n", x ^ y);  // Prints 44
```

### 4.6.4. 按位非

The bitwise NOT operator (`~`) operates on just one operand. For each bit in the sequence, it simply flips the bit such that a zero becomes a one or vice versa. [Table 4](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabNOTTruth) shows the truth table for the bitwise NOT operator.

按位非运算符 (`~`) 仅对一个操作数进行运算。对于序列中的每一位，它只是翻转该位，使 0 变为 1，反之亦然。 [表 4](https://diveintosystems.org/book/C4-Binary/bitwise.html#TabNOTTruth) 显示按位 NOT 运算符的真值表。

Table 4. The Results of Bitwise NOTing a Value (_A_)
表 4. 按位对值进行求值 (_A_) 的结果

|  A  | ~ A |
| :-: | :-: |
|  0  |  1  |
|  1  |  0  |

For example, to bitwise NOT 0b011010, invert the value of each bit:
例如，要按位 NOT 0b011010，请反转每位的值：

```bash
    NOT 011010
Result: 100101
```

To perform a bitwise NOT in C, place a tilde character (`~`) in front of an operand. Here’s the same example again, performed in C:
要在 C 中执行按位 NOT，请在操作数前面放置一个波形符 (`~`)。这是用 C 语言执行的相同示例：

```c
int x = 26;

printf("Result: %d\n", ~x); // Prints -27
```


> [!NOTE] Bitwise NOT vs. Negation
> Note that all modern systems represent integers using two’s complement, so bitwise NOT isn’t quite the same as negation. Bitwise NOT _only_ flips the bits and _doesn’t_ add one.


> [!NOTE] 按位非与取反(Bitwise NOT vs. Negation)
> 请注意，所有现代系统都使用二进制补码来表示整数，因此按位 NOT 与求反并不完全相同。按位非(Bitwise NOT)仅翻转比特位但是不加一。


### 4.6.5. 移位

Another important bitwise operation involves shifting the position of an operand’s bits either to the left (`<<`) or to the right (`>>`). Both the left and right shifting operators take two operands: the bit sequence to shift and the number of places it should be shifted.

另一个重要的按位运算涉及将操作数位的位置左移（`<<`）或右移（`>>`）。左移和右移运算符都采用两个操作数：要移位的位序列和应移位的位数。
#### 左移

Shifting a sequence to the left by _N_ places moves each of its bits to the left _N_ times, appending new zeros to the right side of the sequence. For example, shifting the eight-bit sequence 0b00101101 to the left by two produces 0b101101**00**. The two zeros at the right are appended to end of the sequence, since the result still needs to be an eight-bit sequence.
将序列向左移动_N_位会将其每个位向左移动 _N_ 次，从而将新的零附加到序列的右侧。例如，将八位序列 0b00101101 向左移位两位会产生 0b101101**00**。右侧的两个零被附加到序列的末尾，因为结果仍然需要是八位序列。

In the absence of overflow, shifting to the left _increases_ the value of the result because bits move toward digits that contribute larger powers of two to the value of the number. However, with a fixed number of bits, any bits that shift into positions beyond the maximum capacity of the number get truncated. For example, shifting the eight-bit sequence 0b11110101 (unsigned interpretation 245) to the left by one produces 0b1110101**0** (unsigned interpretation 234). Here, the truncation of the high-order bit that shifted out makes the result smaller.
在没有溢出的情况下，向左移位 _增加_ 结果的值，因为位向让对数字的值贡献更大的2的幂的方向移动。然而，对于固定数量的位数，任何移位到超出数字最大容量的位置的位都会被截断。例如，将八位序列 0b11110101（无符号解释 245）向左移位一位会生成 0b1110101**0**（无符号解释 234）。这里，移出的高位被截断，使得结果变小。

To perform a left bit shift in C, place two less-than characters (`<<`) between a value and the number of places to shift that value:
要在 C 中执行左移位，请在值和要移动该值的位数之间放置两个小于字符 (`<<`)：

```c
int x = 13;  // 13 is 0b00001101

printf("Result: %d\n", x << 3);  // Prints 104 (0b01101000)
```

#### 右移

Shifting to the right is similar to left shifting — any bits that are shifted out of a variable’s capacity (e.g., off the end to the right) disappear due to truncation. However, right shifting introduces an additional consideration: the new bits prepended to the left side of the result may need to be either all zeros or all ones depending on the _type_ of the variable being shifted and its high-order bit value. Conceptually, the choice to prepend zeros or ones resembles that of [sign extension](https://diveintosystems.org/book/C4-Binary/signed.html#_sign_extension). Thus, there exist two distinct variants of right shifting:

- A **logical right shift** always prepends zeros to the high-order bits of the result. Logical shifting is used to shift _unsigned_ variables, since a leading 1 in the most significant bit of an unsigned value isn’t intended to mean that the value is negative. For example, shifting 0b10110011 to the right by two using a logical shift yields 0b**00**101100.
    
- An **arithmetic right shift** prepends a copy of the shifted value’s most significant bit into each of the new bit positions. Arithmetic shifting applies to _signed_ variables, for which it’s important to preserve the signedness of the high-order bits. For example, shifting 0b10110011 to the right by two using an arithmetic shift yields 0b**11**101100.

右移类似于左移——任何移出变量容量的位（例如，从末尾向右移）都会因截断而消失。然而，右移引入了一个额外的考虑因素：结果左侧前面的新位可能需要全为零或全一，具体取决于要移位的变量的类型及其高位位值。从概念上讲，选择在前面添加零或一类似于[符号扩展](https://diveintosystems.org/book/C4-Binary/signed.html#_sign_extension)。因此，右移存在两种不同的变体：

- **逻辑右移**总是在结果的高位前添加零。逻辑移位用于移位 _无符号_ 变量，因为无符号值的最高有效位中的前导 1 并不意味着该值为负数。例如，使用逻辑移位将 0b10110011 向右移动两位会产生 0b**00**101100。
- **算术右移**会将移位值的最高有效位的副本添加到每个新位位置中。算术移位适用于有符号变量，因此保留高位的符号非常重要。例如，使用算术移位将 0b10110011 向右移动两位会得到 0b**11**101100。

Fortunately, when programming in C, you don’t typically need to worry about the distinction if you’ve declared your variables properly. If your program includes a right shift operator (`>>`), virtually every C compiler will automatically perform the appropriate type of shifting according to the type of the shifting variable. That is, if the shifting variable was declared with the _unsigned_ qualifier, the compiler will perform a logical shift. Otherwise, it will perform an arithmetic shift.
幸运的是，在用 C 语言编程时，如果正确声明了变量，通常不需要担心这种区别。如果您的程序包含右移位运算符 (`>>`)，则几乎每个 C 编译器都会根据移位变量的类型自动执行适当类型的移位。也就是说，如果使用 _unsigned_ 限定符声明移位变量，编译器将执行逻辑移位。否则，它将执行算术移位。


> [!NOTE] C Right Shift Example Program
> You can test the behavior of right shifting with a small example program like this one:
> 
> ```c
> #include <stdio.h>
>
>  int main(int argc, char **argv) {
 >     /* Unsigned integer value: u_val. */
 >     unsigned int u_val = 0xFF000000;
>
>      /* Signed integer value: s_val. */
>      int s_val = 0xFF000000;
>
 >   printf("%08X\n", u_val >> 12);  // logical right shift
 >   printf("%08X\n", s_val >> 12);  // arithmetic right shift
>
>   return 0;
>}
> ```
> 
> This program declares two 32-bit integers: one as an unsigned integer (`u_val`), and another as a signed integer (`s_val`). It initializes both integers to the same starting value: a sequence of eight ones followed by 24 zeros (`0b1111111100000000000000000000000000`), and then it shifts both values 12 positions to the right. When executed, it prints:
> 
> ```bash
> $ ./a.out
> 000FF000
> FFFFF000
>```
>
> Because a leading 1 doesn’t indicate "negative" for the unsigned `u_val`, the compiler uses instructions to prepend it with only zeros. The shifted result contains 12 zeros, eight ones, and 12 more zeros (`0b00000000000011111111000000000000`). On the other hand, the leading 1 **does** indicate "negative" for `s_val`, so the compiler prepends 1’s to the front of the shifted value, yielding 20 ones followed by 12 zeros (`0b11111111111111111111000000000000`).



> [!NOTE] C 右移示例程序
> 您可以使用一个小示例程序来测试右移的行为，如下所示：
> 
> ```c
> #include <stdio.h>
>
>  int main(int argc, char **argv) {
 >     /* Unsigned integer value: u_val. */
 >     unsigned int u_val = 0xFF000000;
>
>      /* Signed integer value: s_val. */
>      int s_val = 0xFF000000;
>
 >   printf("%08X\n", u_val >> 12);  // logical right shift
 >   printf("%08X\n", s_val >> 12);  // arithmetic right shift
>
>   return 0;
>}
> ```
> 
> 该程序声明了两个 32 位整数：一个为无符号整数 (`u_val`)，另一个为有符号整数 (`s_val`)。它将两个整数初始化为相同的起始值：由 8 个 1 组成的序列，后跟 24 个 0 (`0b1111111100000000000000000000000000`)，然后将两个值向右移动 12 个位置。执行时，会打印：
> 
> ```bash
> $ ./a.out
> 000FF000
> FFFFF000
>```
>
> 由于前导 1 并不表示无符号`u_val`为“负”，因此编译器使用指令仅在其前面添加零。移位后的结果包含 12 个零、8 个 1 和另外 12 个零 (`0b00000000000011111111000000000000`)。另一方面，前导 1 **确实** 表示 `s_val` 为“负”，因此编译器会在移位值的前面添加 1，生成 20 个 1，后跟 12 个零 (`0b11111111111111111111000000000000`)。
