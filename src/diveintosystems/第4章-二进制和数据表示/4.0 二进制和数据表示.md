From simple stone tablets and cave paintings to written words and phonograph grooves, humans have perpetually sought to record and store information. In this chapter, we’ll characterize how the latest of humanity’s big storage breakthroughs, digital computing, represents information. We also illustrate how to interpret meaning from digital data.

从简单的石碑和洞穴壁画到书面文字和留声机凹槽，人类一直在寻求记录和存储信息。在本章中，我们将描述人类最新的重大存储突破——数字计算——如何表示信息。我们还说明了如何解释数字数据的含义。

Modern computers utilize a variety of media for storing information (e.g., magnetic disks, optical discs, flash memory, tapes, and simple electrical circuits). We characterize storage devices later in [Chapter 11](https://diveintosystems.org/book/C11-MemHierarchy/devices.html#_storage_devices); however, for this discussion, the medium is largely irrelevant — whether there’s a laser scanning the surface of a DVD or a disk head gliding over a magnetic platter, the output from the storage device is ultimately a sequence of electrical signals. To simplify the circuitry, each signal is **binary**, meaning it can take only one of two states: the absence of a voltage (interpreted as zero) and the presence of a voltage (one). This chapter explores how systems encode information into binary, regardless of the original storage medium.

现代计算机利用各种介质来存储信息（例如磁盘、光盘、闪存、磁带和简单电路）。我们稍后将在[第 11 章](https://diveintosystems.org/book/C11-MemHierarchy/devices.html#_storage_devices) 中描述存储设备的特征；然而，对于本次讨论来说，介质在很大程度上是无关紧要的——无论是扫描 DVD 表面的激光还是在磁盘上滑动的磁头，存储设备的输出最终都是一系列电信号。为了简化电路，每个信号都是**二进制**，这意味着它只能采用两种状态之一：不存在电压（解释为零）和存在电压（解释为一）。本章探讨系统如何将信息编码为二进制，而不管原始存储介质是什么。

In binary, each signal corresponds to one **bit** (binary digit) of information: a zero or a one. It may be surprising that all data can be represented using just zeros and ones. Of course, as the complexity of information increases, so does the number of bits needed to represent it. Luckily, the number of unique values doubles for each additional bit in a bit sequence, so a sequence of _N_ bits can represent 2<sup>N</sup> unique values.

在二进制中，每个信号对应一个**位**（二进制数字）信息：零或一。令人惊讶的是，所有数据都可以仅使用零和一来表示。当然，随着信息复杂性的增加，表示信息所需的位数也随之增加。幸运的是，位序列中每增加一位，唯一值的数量就会加倍，因此 _N_ 位序列可以表示2<sup>N</sup>个唯一值。

[Figure 1](https://diveintosystems.org/book/C4-Binary/index.html#FigNumberOfBitsValues) illustrates the growth in the number of representable values as the length of a bit sequence increases. A single bit can represent _two_ values: 0 and 1. Two bits can represent _four_ values: both of the one-bit values with a leading 0 (00 and 01), and both of the one-bit values with a leading 1 (10 and 11). The same pattern applies for any additional bit that extends an existing bit sequence: the new bit can be a 0 or 1, and in either case, the remaining bits represent the same range of values they did prior to the new bit being added. Thus, adding additional bits exponentially increases the number of values the new sequence can represent.

[图 1](https://diveintosystems.org/book/C4-Binary/index.html#FigNumberOfBitsValues) 说明了可表示值的数量随着位序列长度的增加而增长。单个位可以表示两个值：0 和 1。两个位可以表示四个值：两个都以 0 开头的一位值（00 和 01），以及两个以 1 开头的一位值（10 和 11）。相同的模式适用于扩展现有位序列的任何附加位：新位可以是 0 或 1，并且在任何一种情况下，其余位都表示与添加新位之前相同的值范围。因此，添加额外的位会以指数方式增加新序列可以表示的值的数量。

![With one bit, we can represent two values.  Two bits gives us four values, and with three bits we can represent eight values.  Four bits yields 16 unique values.  In general, we can represent 2^N^ values with N bits.](https://diveintosystems.org/book/C4-Binary/_images/NumberOfBitsValues.png)

Figure 1. The values that can be represented with one to four bits. The underlined bits correspond to the prefix coming from the row above.
图 1. 可以用一到四位表示的值。带下划线的位对应于来自上面行的前缀。

Because a single bit doesn’t represent much information, storage systems commonly group bits into longer sequences for storing more interesting values. The most ubiquitous grouping is a **byte**, which is a collection of eight bits. One byte represents 28 = 256 unique values (0-255) — enough to enumerate the letters and common punctuation symbols of the English language. Bytes are the smallest unit of addressable memory in a computer system, meaning a program can’t ask for fewer than eight bits to store a variable.

由于单个位不能代表太多信息，因此存储系统通常将位分组为更长的序列以存储更多有趣的值。最普遍的分组是**字节**，它是八位的集合。一个字节代表 28 = 256 个唯一值 (0-255) — 足以枚举英语字母和常见标点符号。字节是计算机系统中可寻址内存的最小单位，这意味着程序不能要求少于八位来存储变量。

Modern CPUs also typically define a **word** as either 32 bits or 64 bits, depending on the design of the hardware. The size of a word determines the "default" size a system’s hardware uses to move data from one component to another (e.g., between memory and registers). These larger sequences are necessary for storing numbers, since programs often need to count higher than 256!
  
现代 CPU 通常还将**字**定义为 32 位或 64 位，具体取决于硬件的设计。字的大小决定了系统硬件用于将数据从一个组件移动到另一个组件（例如，在内存和寄存器之间）的“默认”大小。这些更大的序列对于存储数字是必要的，因为程序通常需要计算高于 256 的数字！

If you’ve programmed in C, you know that you must [declare a variable before using it](https://diveintosystems.org/book/C1-C_intro/getting_started.html#_variables_and_c_numeric_types). Such declarations inform the C compiler of two important properties regarding the variable’s binary representation: the number of bits to allocate for it, and the way in which the program intends to interpret those bits. Conceptually, the number of bits is straightforward, as the compiler simply looks up [how many bits are associated with the declared type](https://diveintosystems.org/book/C1-C_intro/getting_started.html#_c_numeric_types) (e.g., a `char` is one byte) and associates that amount of memory with the variable. The interpretation of a sequence of bits is much more conceptually interesting. All data in a computer’s memory is stored as bits, but bits have no _inherent_ meaning. For example, even with just a single bit, you could interpret the bit’s two values in many different ways: up and down, black and white, yes and no, on and off, etc.

如果您用 C 语言编程，您就会知道必须[在使用变量之前声明它](https://diveintosystems.org/book/C1-C_intro/getting_started.html#_variables_and_c_numeric_types)。此类声明告知 C 编译器有关变量二进制表示形式的两个重要属性：为其分配的位数，以及程序打算解释这些位的方式。从概念上讲，位数很简单，因为编译器只需查找[与声明的类型相关联的位数](https://diveintosystems.org/book/C1-C_intro/getting_started.html#_c_numeric_types)（例如，`char`是一个字节）并将该内存量与变量相关联。位序列的解释在概念上更有趣。计算机内存中的所有数据都以位的形式存储，但位没有 _固有_ 含义。例如，即使只有一个位，您也可以用多种不同的方式解释该位的两个值：向上和向下、黑色和白色、是和否、开和关等。

Extending the length of a bit sequence expands the range of its interpretations. For example, a `char` variable uses the American Standard Code for Information Interchange (ASCII) encoding standard, which defines how an eight-bit binary value corresponds to English letters and punctuation symbols. [Table 1](https://diveintosystems.org/book/C4-Binary/index.html#TabAscii) shows a small subset of the ASCII standard (for a full reference, run `man ascii` on the command line). There’s no special reason why the character `'X'` needs to correspond to 01011000, so don’t bother memorizing the table. What matters is that every program storing letters agrees on their bit sequence interpretation, which is why ASCII is defined by a standards committee.

扩展位序列的长度扩大了其解释的范围。例如，`char`变量使用美国信息交换标准代码 (ASCII) 编码标准，该标准定义了八位二进制值如何对应于英文字母和标点符号。 [表 1](https://diveintosystems.org/book/C4-Binary/index.html#TabAscii) 显示了 ASCII 标准的一小部分（如需完整参考，请在命令行上运行“man ascii”）。没有什么特殊原因为什么字符“X”需要对应01011000，所以不用费心去记这个表。重要的是每个存储字母的程序都同意其位序列解释，这就是标准委员会定义 ASCII 的原因。

Table 1. A Small Snippet of the Eight-Bit ASCII Character Encoding Standard
表 1. 八位 ASCII 字符编码标准的一个小片段

|Binary value|Character interpretation|Binary value|Character interpretation|
|---|---|---|---|
|01010111|W|00100000|space|
|01011000|X|00100001|!|
|01011001|Y|00100010|"|
|01011010|Z|00100011|#|

Any information can be encoded in binary, including rich data like graphics and audio. For example, suppose that an image encoding scheme defines 00, 01, 10, and 11 to correspond to the colors white, orange, blue, and black. [Figure 2](https://diveintosystems.org/book/C4-Binary/index.html#FigImageRepresentation) illustrates how we might use this simple two-bit encoding strategy to draw a crude image of a fish using only 12 bytes. In part a, each cell of the image equates to one two-bit sequence. Parts b and c show the corresponding binary encoding as two-bit and byte sequences, respectively. Although this example encoding scheme is simplified for learning purposes, the general idea is similar to what real graphics systems use, albeit with many more bits for a wider range of colors.

任何信息都可以二进制编码，包括图形和音频等丰富的数据。例如，假设图像编码方案定义 00、01、10 和 11 对应于白色、橙色、蓝色和黑色。 [图 2](https://diveintosystems.org/book/C4-Binary/index.html#FigImageRepresentation) 展示了我们如何使用这种简单的两位编码策略仅使用 12 个字节来绘制鱼的原始图像。在 a 部分中，图像的每个单元相当于一个两位序列。 b 和 c 部分分别将相应的二进制编码显示为两位和字节序列。尽管出于学习目的而简化了示例编码方案，但总体思路与真实图形系统使用的类似，尽管具有更多位用于更广泛的颜色。

![A fish image with a blue (10) background, white (00) eye, black (11) pupil, and orange (01) body.](https://diveintosystems.org/book/C4-Binary/_images/ImageRepresentation.png)

Figure 2. The (a) image representation, (b) two-bit cell representation, and (c) byte representation of a simple fish image.
图 2. 简单鱼图像的 (a) 图像表示、(b) 两位单元表示和 (c) 字节表示。

Having just introduced two encoding schemes, the same bit sequence, 01011010, might mean the character `'Z'` to a text editor, whereas a graphics program might interpret it as part of a fish’s tail fin. Which interpretation is correct depends on the context. Despite the underlying bits being the same, humans often find some interpretations much easier to comprehend than others (e.g., perceiving the fish as colored cells rather than a table of bytes).

刚刚介绍了两种编码方案，相同的位序列 01011010 对于文本编辑器来说可能意味着字符`Z`，而图形程序可能会将其解释为鱼尾鳍的一部分。哪种解释是正确的取决于上下文。尽管底层的位是相同的，但人类经常发现某些解释比其他解释更容易理解（例如，将鱼视为彩色细胞而不是字节表）。

The remainder of this chapter largely deals with representing and manipulating binary numbers, but the overall point bears repeating: all information is stored in a computer’s memory as 0’s and 1’s, and it’s up to programs or the people running them to interpret the meaning of those bits.

本章的其余部分主要讨论二进制数的表示和操作，但总体要点值得重复：所有信息都以 0 和 1 的形式存储在计算机内存中，并且由程序或运行程序的人员来解释这些位的含义。